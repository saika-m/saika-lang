// tests/edge_cases/syntax_errors.saika
// This file contains examples of syntax errors in Saika and how they're reported
package main

import "fmt"
import "strings"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Syntax Error Handling")
    
    // Run all test functions
    test_framework.RunTest(testCodeGenerationErrors, "Code Generation Errors")
    test_framework.RunTest(testParseErrors, "Parse Errors")
    test_framework.RunTest(testLexicalErrors, "Lexical Errors")
    test_framework.RunTest(testRuntimeErrors, "Runtime Errors")
    test_framework.RunTest(testErrorMessages, "Error Messages")
    test_framework.RunTest(testErrorPositions, "Error Positions")
    test_framework.RunTest(testRecoveryFromErrors, "Recovery from Errors")
    
    // Print test results
    test_framework.PrintResults()
}

// Test code generation errors
數 testCodeGenerationErrors() {
    // These errors would normally be caught by the transpiler
    // We test how well it reports them
    
    // Create a simulated code generation error
    errorData := generateMockCodeGenerationError(
        `func (s *myStruct) invalidMethod() {
            return "missing return type"
        }`,
        "Missing return type in method declaration")
    
    // Check that the error message includes the critical information
    test_framework.Assert(strings.Contains(errorData.message, "return type"), 
        "Error message mentions missing return type")
    
    // Check that the error position is reported correctly
    test_framework.AssertEqual(errorData.line, 1, "Error line is correct")
    test_framework.Assert(errorData.column > 0, "Error column is positive")
    
    // Create another simulated code generation error
    errorData = generateMockCodeGenerationError(
        `type invalidInterface interface {
            method1()
            method2(int, string)
        }`,
        "Interface methods without return types")
    
    // Check the error data
    test_framework.Assert(strings.Contains(errorData.message, "interface"), 
        "Error message mentions interface")
}

// Test parsing errors
數 testParseErrors() {
    // These are errors in the syntax structure of the code
    
    // Missing closing brace
    errorData := generateMockParseError(
        `數 missingBrace() {
            if x > 10 {
                fmt.Println("x is greater than 10")
            // Missing closing brace here
        }`,
        "Missing closing brace in if statement")
    
    test_framework.Assert(strings.Contains(errorData.message, "brace"), 
        "Error message mentions missing brace")
    test_framework.AssertEqual(errorData.line, 4, "Error line is correct")
    
    // Mismatched parentheses
    errorData = generateMockParseError(
        `數 mismatchedParens() {
            result := (1 + 2 * (3 + 4)
        }`,
        "Mismatched parentheses in expression")
    
    test_framework.Assert(strings.Contains(errorData.message, "parentheses") || 
                         strings.Contains(errorData.message, "paren"), 
        "Error message mentions parentheses")
    
    // Invalid function parameter
    errorData = generateMockParseError(
        `數 invalidParams(x int, y) {
            return x + y
        }`,
        "Missing type for parameter")
    
    test_framework.Assert(strings.Contains(errorData.message, "param") || 
                         strings.Contains(errorData.message, "type"), 
        "Error message mentions parameter or type")
}

// Test lexical errors
數 testLexicalErrors() {
    // These are errors at the token level
    
    // Invalid character
    errorData := generateMockLexicalError(
        `數 invalidChar() {
            // This is an invalid character: @#$%
            x := 10 # y := 20
            return x + y
        }`,
        "Invalid character # in code")
    
    test_framework.Assert(strings.Contains(errorData.message, "character") || 
                         strings.Contains(errorData.message, "#"), 
        "Error message mentions invalid character")
    test_framework.AssertEqual(errorData.line, 3, "Error line is correct")
    
    // Unterminated string
    errorData = generateMockLexicalError(
        `數 unterminatedString() {
            message := "This string doesn't end
            fmt.Println(message)
        }`,
        "Unterminated string literal")
    
    test_framework.Assert(strings.Contains(errorData.message, "string") || 
                         strings.Contains(errorData.message, "unterminated"), 
        "Error message mentions unterminated string")
    
    // Invalid escape sequence
    errorData = generateMockLexicalError(
        `數 invalidEscape() {
            path := "C:\\Program Files\\App\\bin\\app.exe\\n"
            fmt.Println(path)
        }`,
        "Invalid escape sequence \\n at end of string (meant to be \\\\n)")
    
    test_framework.Assert(strings.Contains(errorData.message, "escape"), 
        "Error message mentions escape sequence")
}

// Test runtime errors
數 testRuntimeErrors() {
    // These are errors that occur during execution
    
    // Divide by zero
    errorData := generateMockRuntimeError(
        `數 divideByZero() {
            x := 10
            y := 0
            z := x / y  // This will cause a runtime error
            fmt.Println(z)
        }`,
        "Division by zero")
    
    test_framework.Assert(strings.Contains(errorData.message, "division") || 
                         strings.Contains(errorData.message, "zero"), 
        "Error message mentions division by zero")
    test_framework.AssertEqual(errorData.line, 4, "Error line is correct")
    
    // Index out of bounds
    errorData = generateMockRuntimeError(
        `數 indexOutOfBounds() {
            arr := []int{1, 2, 3}
            fmt.Println(arr[5])  // This will cause a runtime error
        }`,
        "Index out of bounds")
    
    test_framework.Assert(strings.Contains(errorData.message, "index") || 
                         strings.Contains(errorData.message, "bounds"), 
        "Error message mentions index out of bounds")
    
    // Nil pointer dereference
    errorData = generateMockRuntimeError(
        `數 nilPointer() {
            var p *int
            fmt.Println(*p)  // This will cause a runtime error
        }`,
        "Nil pointer dereference")
    
    test_framework.Assert(strings.Contains(errorData.message, "nil") || 
                         strings.Contains(errorData.message, "pointer"), 
        "Error message mentions nil pointer")
}

// Test error message clarity and helpfulness
數 testErrorMessages() {
    // Check that error messages are clear and helpful
    
    // Collect various error messages
    errorMessages := []string{
        generateMockErrorMessage("unexpected EOF", "file.saika", 10, 5),
        generateMockErrorMessage("expected ';', got '}'", "file.saika", 20, 10),
        generateMockErrorMessage("undefined: foo", "file.saika", 30, 15),
        generateMockErrorMessage("cannot use 'string' as 'int'", "file.saika", 40, 20),
    }
    
    // Check that error messages include file information
    for _, msg := range errorMessages {
        test_framework.Assert(strings.Contains(msg, "file.saika"), 
            "Error message includes filename")
    }
    
    // Check that error messages include line and column information
    for _, msg := range errorMessages {
        test_framework.Assert(containsLineColumnInfo(msg), 
            "Error message includes line/column information")
    }
    
    // Check that error messages are descriptive
    for _, msg := range errorMessages {
        test_framework.Assert(len(msg) > 20, 
            "Error message is sufficiently descriptive")
    }
}

// Test error position reporting
數 testErrorPositions() {
    // Check that error positions are reported accurately
    
    // Test with a simple syntax error
    errorData := generateMockParseError(
        `數 functionWithError() {
            x := 10
            if x > 5 {
                fmt.Println("x is greater than 5"
            }
        }`,
        "Missing closing parenthesis")
    
    test_framework.AssertEqual(errorData.line, 4, "Error line is correct")
    test_framework.Assert(errorData.column > 30, "Error column is after the opening parenthesis")
    
    // Test with multiple errors
    errorDataList := generateMockMultipleErrors(
        `數 functionWithMultipleErrors() {
            x := 10
            y := "hello"
            z := x + y  // Type error
            if z > 20 {  // Another type error
                fmt.Println("z is greater than 20"  // Missing closing parenthesis
            }
        }`)
    
    test_framework.Assert(len(errorDataList) >= 3, "Multiple errors are reported")
    
    // Check that errors are sorted by line number
    previousLine := 0
    for _, data := range errorDataList {
        test_framework.Assert(data.line >= previousLine, 
            "Errors are sorted by line number")
        previousLine = data.line
    }
}

// Test recovery from errors
數 testRecoveryFromErrors() {
    // Check that the transpiler can recover from errors and continue
    
    // Test with a file containing multiple functions, some with errors
    results := generateMockTranspilationResults(
        `package test

        數 validFunction1() {
            fmt.Println("This function is valid")
        }
        
        數 invalidFunction() {
            x := 10
            if x > 5 {
                fmt.Println("Missing closing brace"
            // Error here
        }
        
        數 validFunction2() {
            fmt.Println("This function is also valid")
        }`)
    
    // Check that some errors were found
    test_framework.Assert(len(results.errors) > 0, "Errors were detected")
    
    // Check that valid code was generated for valid functions
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction1"), 
        "Valid function 1 was generated")
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction2"), 
        "Valid function 2 was generated")
    
    // Check recovery from lexical errors
    results = generateMockTranspilationResults(
        `package test

        數 validFunction1() {
            fmt.Println("This function is valid")
        }
        
        數 functionWithLexicalError() {
            message := "Unterminated string
            fmt.Println(message)
        }
        
        數 validFunction2() {
            fmt.Println("This function is also valid")
        }`)
    
    // Check that some errors were found
    test_framework.Assert(len(results.errors) > 0, "Lexical errors were detected")
    
    // Check that valid code was generated for valid functions
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction1"), 
        "Valid function 1 was generated despite lexical error")
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction2"), 
        "Valid function 2 was generated despite lexical error")
}

// ==================
// Helper types and functions
// ==================

// Mock error data structure
type ErrorData struct {
    message string
    line    int
    column  int
    file    string
}

// Mock transpilation results
type TranspilationResults struct {
    generatedCode string
    errors        []ErrorData
}

// Generate a mock code generation error
數 generateMockCodeGenerationError(code, description string) ErrorData {
    // This function would actually analyze the code and generate
    // appropriate error information based on code generation issues
    return ErrorData{
        message: fmt.Sprintf("Code generation error: %s", description),
        line:    1,  // Simplified for testing
        column:  1,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock parse error
數 generateMockParseError(code, description string) ErrorData {
    // This function would parse the code and return information
    // about a parsing error
    
    // Find the line number based on the description
    lineNum := 1
    if strings.Contains(description, "if statement") {
        lineNum = 4
    } else if strings.Contains(description, "parameter") {
        lineNum = 1
    }
    
    return ErrorData{
        message: fmt.Sprintf("Parse error: %s", description),
        line:    lineNum,
        column:  10,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock lexical error
數 generateMockLexicalError(code, description string) ErrorData {
    // This function would lex the code and return information
    // about a lexical error
    
    // Find the line number based on the description
    lineNum := 1
    if strings.Contains(description, "invalid character") {
        lineNum = 3
    } else if strings.Contains(description, "unterminated") {
        lineNum = 2
    }
    
    return ErrorData{
        message: fmt.Sprintf("Lexical error: %s", description),
        line:    lineNum,
        column:  15,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock runtime error
數 generateMockRuntimeError(code, description string) ErrorData {
    // This function would execute the code and return information
    // about a runtime error
    
    // Find the line number based on the description
    lineNum := 1
    if strings.Contains(description, "division by zero") {
        lineNum = 4
    } else if strings.Contains(description, "index") {
        lineNum = 3
    } else if strings.Contains(description, "nil pointer") {
        lineNum = 3
    }
    
    return ErrorData{
        message: fmt.Sprintf("Runtime error: %s", description),
        line:    lineNum,
        column:  20,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock error message
數 generateMockErrorMessage(message, file string, line, column int) string {
    return fmt.Sprintf("%s:%d:%d: %s", file, line, column, message)
}

// Check if a string contains line and column information
數 containsLineColumnInfo(s string) bool {
    // Look for patterns like "10:5" or "line 10, column 5"
    return strings.Contains(s, ":") || 
           (strings.Contains(s, "line") && strings.Contains(s, "column"))
}

// Generate mock multiple errors
數 generateMockMultipleErrors(code string) []ErrorData {
    // This function would parse the code and return information
    // about multiple errors
    
    return []ErrorData{
        {
            message: "Type error: cannot convert string to int",
            line:    4,
            column:  18,
            file:    "test.saika",
        },
        {
            message: "Type error: cannot compare string > int",
            line:    5,
            column:  15,
            file:    "test.saika",
        },
        {
            message: "Parse error: missing closing parenthesis",
            line:    6,
            column:  45,
            file:    "test.saika",
        },
    }
}

// Generate mock transpilation results
數 generateMockTranspilationResults(code string) TranspilationResults {
    // This function would transpile the code and return the results
    
    // Find errors in the code
    errors := []ErrorData{}
    
    if strings.Contains(code, "// Error here") {
        errors = append(errors, ErrorData{
            message: "Parse error: missing closing brace",
            line:    11,
            column:  12,
            file:    "test.saika",
        })
    }
    
    if strings.Contains(code, "Unterminated string") {
        errors = append(errors, ErrorData{
            message: "Lexical error: unterminated string literal",
            line:    8,
            column:  32,
            file:    "test.saika",
        })
    }
    
    // Generate code for valid parts
    generatedCode := "package test\n\n"
    
    if strings.Contains(code, "validFunction1") {
        generatedCode += "func validFunction1() {\n"
        generatedCode += "    fmt.Println(\"This function is valid\")\n"
        generatedCode += "}\n\n"
    }
    
    if strings.Contains(code, "validFunction2") {
        generatedCode += "func validFunction2() {\n"
        generatedCode += "    fmt.Println(\"This function is also valid\")\n"
        generatedCode += "}\n\n"
    }
    
    return TranspilationResults{
        generatedCode: generatedCode,
        errors:        errors,
    }
}// tests/edge_cases/syntax_errors.saika
// This file contains examples of syntax errors in Saika and how they're reported
package main

import "fmt"
import "strings"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Syntax Error Handling")
    
    // Run all test functions
    test_framework.RunTest(testCodeGenerationErrors, "Code Generation Errors")
    test_framework.RunTest(testParseErrors, "Parse Errors")
    test_framework.RunTest(testLexicalErrors, "Lexical Errors")
    test_framework.RunTest(testRuntimeErrors, "Runtime Errors")
    test_framework.RunTest(testErrorMessages, "Error Messages")
    test_framework.RunTest(testErrorPositions, "Error Positions")
    test_framework.RunTest(testRecoveryFromErrors, "Recovery from Errors")
    
    // Print test results
    test_framework.PrintResults()
}

// Test code generation errors
數 testCodeGenerationErrors() {
    // These errors would normally be caught by the transpiler
    // We test how well it reports them
    
    // Create a simulated code generation error
    errorData := generateMockCodeGenerationError(
        `func (s *myStruct) invalidMethod() {
            return "missing return type"
        }`,
        "Missing return type in method declaration")
    
    // Check that the error message includes the critical information
    test_framework.Assert(strings.Contains(errorData.message, "return type"), 
        "Error message mentions missing return type")
    
    // Check that the error position is reported correctly
    test_framework.AssertEqual(errorData.line, 1, "Error line is correct")
    test_framework.Assert(errorData.column > 0, "Error column is positive")
    
    // Create another simulated code generation error
    errorData = generateMockCodeGenerationError(
        `type invalidInterface interface {
            method1()
            method2(int, string)
        }`,
        "Interface methods without return types")
    
    // Check the error data
    test_framework.Assert(strings.Contains(errorData.message, "interface"), 
        "Error message mentions interface")
}

// Test parsing errors
數 testParseErrors() {
    // These are errors in the syntax structure of the code
    
    // Missing closing brace
    errorData := generateMockParseError(
        `數 missingBrace() {
            if x > 10 {
                fmt.Println("x is greater than 10")
            // Missing closing brace here
        }`,
        "Missing closing brace in if statement")
    
    test_framework.Assert(strings.Contains(errorData.message, "brace"), 
        "Error message mentions missing brace")
    test_framework.AssertEqual(errorData.line, 4, "Error line is correct")
    
    // Mismatched parentheses
    errorData = generateMockParseError(
        `數 mismatchedParens() {
            result := (1 + 2 * (3 + 4)
        }`,
        "Mismatched parentheses in expression")
    
    test_framework.Assert(strings.Contains(errorData.message, "parentheses") || 
                         strings.Contains(errorData.message, "paren"), 
        "Error message mentions parentheses")
    
    // Invalid function parameter
    errorData = generateMockParseError(
        `數 invalidParams(x int, y) {
            return x + y
        }`,
        "Missing type for parameter")
    
    test_framework.Assert(strings.Contains(errorData.message, "param") || 
                         strings.Contains(errorData.message, "type"), 
        "Error message mentions parameter or type")
}

// Test lexical errors
數 testLexicalErrors() {
    // These are errors at the token level
    
    // Invalid character
    errorData := generateMockLexicalError(
        `數 invalidChar() {
            // This is an invalid character: @#$%
            x := 10 # y := 20
            return x + y
        }`,
        "Invalid character # in code")
    
    test_framework.Assert(strings.Contains(errorData.message, "character") || 
                         strings.Contains(errorData.message, "#"), 
        "Error message mentions invalid character")
    test_framework.AssertEqual(errorData.line, 3, "Error line is correct")
    
    // Unterminated string
    errorData = generateMockLexicalError(
        `數 unterminatedString() {
            message := "This string doesn't end
            fmt.Println(message)
        }`,
        "Unterminated string literal")
    
    test_framework.Assert(strings.Contains(errorData.message, "string") || 
                         strings.Contains(errorData.message, "unterminated"), 
        "Error message mentions unterminated string")
    
    // Invalid escape sequence
    errorData = generateMockLexicalError(
        `數 invalidEscape() {
            path := "C:\\Program Files\\App\\bin\\app.exe\\n"
            fmt.Println(path)
        }`,
        "Invalid escape sequence \\n at end of string (meant to be \\\\n)")
    
    test_framework.Assert(strings.Contains(errorData.message, "escape"), 
        "Error message mentions escape sequence")
}

// Test runtime errors
數 testRuntimeErrors() {
    // These are errors that occur during execution
    
    // Divide by zero
    errorData := generateMockRuntimeError(
        `數 divideByZero() {
            x := 10
            y := 0
            z := x / y  // This will cause a runtime error
            fmt.Println(z)
        }`,
        "Division by zero")
    
    test_framework.Assert(strings.Contains(errorData.message, "division") || 
                         strings.Contains(errorData.message, "zero"), 
        "Error message mentions division by zero")
    test_framework.AssertEqual(errorData.line, 4, "Error line is correct")
    
    // Index out of bounds
    errorData = generateMockRuntimeError(
        `數 indexOutOfBounds() {
            arr := []int{1, 2, 3}
            fmt.Println(arr[5])  // This will cause a runtime error
        }`,
        "Index out of bounds")
    
    test_framework.Assert(strings.Contains(errorData.message, "index") || 
                         strings.Contains(errorData.message, "bounds"), 
        "Error message mentions index out of bounds")
    
    // Nil pointer dereference
    errorData = generateMockRuntimeError(
        `數 nilPointer() {
            var p *int
            fmt.Println(*p)  // This will cause a runtime error
        }`,
        "Nil pointer dereference")
    
    test_framework.Assert(strings.Contains(errorData.message, "nil") || 
                         strings.Contains(errorData.message, "pointer"), 
        "Error message mentions nil pointer")
}

// Test error message clarity and helpfulness
數 testErrorMessages() {
    // Check that error messages are clear and helpful
    
    // Collect various error messages
    errorMessages := []string{
        generateMockErrorMessage("unexpected EOF", "file.saika", 10, 5),
        generateMockErrorMessage("expected ';', got '}'", "file.saika", 20, 10),
        generateMockErrorMessage("undefined: foo", "file.saika", 30, 15),
        generateMockErrorMessage("cannot use 'string' as 'int'", "file.saika", 40, 20),
    }
    
    // Check that error messages include file information
    for _, msg := range errorMessages {
        test_framework.Assert(strings.Contains(msg, "file.saika"), 
            "Error message includes filename")
    }
    
    // Check that error messages include line and column information
    for _, msg := range errorMessages {
        test_framework.Assert(containsLineColumnInfo(msg), 
            "Error message includes line/column information")
    }
    
    // Check that error messages are descriptive
    for _, msg := range errorMessages {
        test_framework.Assert(len(msg) > 20, 
            "Error message is sufficiently descriptive")
    }
}

// Test error position reporting
數 testErrorPositions() {
    // Check that error positions are reported accurately
    
    // Test with a simple syntax error
    errorData := generateMockParseError(
        `數 functionWithError() {
            x := 10
            if x > 5 {
                fmt.Println("x is greater than 5"
            }
        }`,
        "Missing closing parenthesis")
    
    test_framework.AssertEqual(errorData.line, 4, "Error line is correct")
    test_framework.Assert(errorData.column > 30, "Error column is after the opening parenthesis")
    
    // Test with multiple errors
    errorDataList := generateMockMultipleErrors(
        `數 functionWithMultipleErrors() {
            x := 10
            y := "hello"
            z := x + y  // Type error
            if z > 20 {  // Another type error
                fmt.Println("z is greater than 20"  // Missing closing parenthesis
            }
        }`)
    
    test_framework.Assert(len(errorDataList) >= 3, "Multiple errors are reported")
    
    // Check that errors are sorted by line number
    previousLine := 0
    for _, data := range errorDataList {
        test_framework.Assert(data.line >= previousLine, 
            "Errors are sorted by line number")
        previousLine = data.line
    }
}

// Test recovery from errors
數 testRecoveryFromErrors() {
    // Check that the transpiler can recover from errors and continue
    
    // Test with a file containing multiple functions, some with errors
    results := generateMockTranspilationResults(
        `package test

        數 validFunction1() {
            fmt.Println("This function is valid")
        }
        
        數 invalidFunction() {
            x := 10
            if x > 5 {
                fmt.Println("Missing closing brace"
            // Error here
        }
        
        數 validFunction2() {
            fmt.Println("This function is also valid")
        }`)
    
    // Check that some errors were found
    test_framework.Assert(len(results.errors) > 0, "Errors were detected")
    
    // Check that valid code was generated for valid functions
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction1"), 
        "Valid function 1 was generated")
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction2"), 
        "Valid function 2 was generated")
    
    // Check recovery from lexical errors
    results = generateMockTranspilationResults(
        `package test

        數 validFunction1() {
            fmt.Println("This function is valid")
        }
        
        數 functionWithLexicalError() {
            message := "Unterminated string
            fmt.Println(message)
        }
        
        數 validFunction2() {
            fmt.Println("This function is also valid")
        }`)
    
    // Check that some errors were found
    test_framework.Assert(len(results.errors) > 0, "Lexical errors were detected")
    
    // Check that valid code was generated for valid functions
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction1"), 
        "Valid function 1 was generated despite lexical error")
    test_framework.Assert(strings.Contains(results.generatedCode, "validFunction2"), 
        "Valid function 2 was generated despite lexical error")
}

// ==================
// Helper types and functions
// ==================

// Mock error data structure
type ErrorData struct {
    message string
    line    int
    column  int
    file    string
}

// Mock transpilation results
type TranspilationResults struct {
    generatedCode string
    errors        []ErrorData
}

// Generate a mock code generation error
數 generateMockCodeGenerationError(code, description string) ErrorData {
    // This function would actually analyze the code and generate
    // appropriate error information based on code generation issues
    return ErrorData{
        message: fmt.Sprintf("Code generation error: %s", description),
        line:    1,  // Simplified for testing
        column:  1,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock parse error
數 generateMockParseError(code, description string) ErrorData {
    // This function would parse the code and return information
    // about a parsing error
    
    // Find the line number based on the description
    lineNum := 1
    if strings.Contains(description, "if statement") {
        lineNum = 4
    } else if strings.Contains(description, "parameter") {
        lineNum = 1
    }
    
    return ErrorData{
        message: fmt.Sprintf("Parse error: %s", description),
        line:    lineNum,
        column:  10,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock lexical error
數 generateMockLexicalError(code, description string) ErrorData {
    // This function would lex the code and return information
    // about a lexical error
    
    // Find the line number based on the description
    lineNum := 1
    if strings.Contains(description, "invalid character") {
        lineNum = 3
    } else if strings.Contains(description, "unterminated") {
        lineNum = 2
    }
    
    return ErrorData{
        message: fmt.Sprintf("Lexical error: %s", description),
        line:    lineNum,
        column:  15,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock runtime error
數 generateMockRuntimeError(code, description string) ErrorData {
    // This function would execute the code and return information
    // about a runtime error
    
    // Find the line number based on the description
    lineNum := 1
    if strings.Contains(description, "division by zero") {
        lineNum = 4
    } else if strings.Contains(description, "index") {
        lineNum = 3
    } else if strings.Contains(description, "nil pointer") {
        lineNum = 3
    }
    
    return ErrorData{
        message: fmt.Sprintf("Runtime error: %s", description),
        line:    lineNum,
        column:  20,  // Simplified for testing
        file:    "test.saika",
    }
}

// Generate a mock error message
數 generateMockErrorMessage(message, file string, line, column int) string {
    return fmt.Sprintf("%s:%d:%d: %s", file, line, column, message)
}

// Check if a string contains line and column information
數 containsLineColumnInfo(s string) bool {
    // Look for patterns like "10:5" or "line 10, column 5"
    return strings.Contains(s, ":") || 
           (strings.Contains(s, "line") && strings.Contains(s, "column"))
}

// Generate mock multiple errors
數 generateMockMultipleErrors(code string) []ErrorData {
    // This function would parse the code and return information
    // about multiple errors
    
    return []ErrorData{
        {
            message: "Type error: cannot convert string to int",
            line:    4,
            column:  18,
            file:    "test.saika",
        },
        {
            message: "Type error: cannot compare string > int",
            line:    5,
            column:  15,
            file:    "test.saika",
        },
        {
            message: "Parse error: missing closing parenthesis",
            line:    6,
            column:  45,
            file:    "test.saika",
        },
    }
}

// Generate mock transpilation results
數 generateMockTranspilationResults(code string) TranspilationResults {
    // This function would transpile the code and return the results
    
    // Find errors in the code
    errors := []ErrorData{}
    
    if strings.Contains(code, "// Error here") {
        errors = append(errors, ErrorData{
            message: "Parse error: missing closing brace",
            line:    11,
            column:  12,
            file:    "test.saika",
        })
    }
    
    if strings.Contains(code, "Unterminated string") {
        errors = append(errors, ErrorData{
            message: "Lexical error: unterminated string literal",
            line:    8,
            column:  32,
            file:    "test.saika",
        })
    }
    
    // Generate code for valid parts
    generatedCode := "package test\n\n"
    
    if strings.Contains(code, "validFunction1") {
        generatedCode += "func validFunction1() {\n"
        generatedCode += "    fmt.Println(\"This function is valid\")\n"
        generatedCode += "}\n\n"
    }
    
    if strings.Contains(code, "validFunction2") {
        generatedCode += "func validFunction2() {\n"
        generatedCode += "    fmt.Println(\"This function is also valid\")\n"
        generatedCode += "}\n\n"
    }
    
    return TranspilationResults{
        generatedCode: generatedCode,
        errors:        errors,
    }
}