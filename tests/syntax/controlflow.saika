// tests/syntax/controlflow.saika
// Tests for control flow statements in Saika
package main

import "fmt"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Control Flow Statements")
    
    // Run all test functions
    test_framework.RunTest(testIfStatement, "If Statement")
    test_framework.RunTest(testIfElseStatement, "If-Else Statement")
    test_framework.RunTest(testIfElseIfStatement, "If-Else-If Statement")
    test_framework.RunTest(testForLoop, "For Loop")
    test_framework.RunTest(testForRangeLoop, "For-Range Loop")
    test_framework.RunTest(testWhileStyleLoop, "While-Style Loop")
    test_framework.RunTest(testBreakStatement, "Break Statement")
    test_framework.RunTest(testContinueStatement, "Continue Statement")
    test_framework.RunTest(testSwitchStatement, "Switch Statement")
    test_framework.RunTest(testSwitchWithFallthrough, "Switch with Fallthrough")
    test_framework.RunTest(testTypeSwitch, "Type Switch")
    test_framework.RunTest(testDeferStatement, "Defer Statement")
    test_framework.RunTest(testGotoStatement, "Goto Statement")
    test_framework.RunTest(testNestedControlFlow, "Nested Control Flow")
    
    // Print test results
    test_framework.PrintResults()
}

// Test basic if statement
數 testIfStatement() {
    // Basic if statement
    let x = 10
    let passed = false
    
    if x > 5 {
        passed = true
    }
    
    test_framework.Assert(passed, "If condition evaluated correctly")
    
    // If with initialization statement
    if y := 20; y > 15 {
        test_framework.Assert(true, "If with initialization passed")
    }
    
    // Scope of the initialized variable
    if z := 30; z > 25 {
        test_framework.Assert(z == 30, "z is in scope inside if")
    }
    // z should not be accessible here
    
    // Compound conditions
    if x > 5 && x < 15 {
        test_framework.Assert(true, "Compound && condition passed")
    }
    
    if x < 5 || x > 5 {
        test_framework.Assert(true, "Compound || condition passed")
    }
}

// Test if-else statement
數 testIfElseStatement() {
    // Basic if-else
    let x = 10
    let result = ""
    
    if x > 20 {
        result = "greater"
    } else {
        result = "lesser or equal"
    }
    
    test_framework.AssertEqual(result, "lesser or equal", "if-else branch taken correctly")
    
    // If-else with initialization
    if y := 5; y > 10 {
        result = "y is large"
    } else {
        result = "y is small"
    }
    
    test_framework.AssertEqual(result, "y is small", "if-else with initialization branch taken correctly")
    
    // If with side effects
    let count = 0
    if incrementAndCheck(&count) {
        test_framework.AssertEqual(count, 1, "Side effect occurred")
    }
}

// Test if-else-if statement
數 testIfElseIfStatement() {
    // If-else-if chain
    let x = 10
    let category = ""
    
    if x < 0 {
        category = "negative"
    } else if x == 0 {
        category = "zero"
    } else if x < 10 {
        category = "small positive"
    } else {
        category = "large positive"
    }
    
    test_framework.AssertEqual(category, "large positive", "if-else-if chain categorized correctly")
    
    // Complex if-else-if
    let score = 85
    let grade = ""
    
    if score >= 90 {
        grade = "A"
    } else if score >= 80 {
        grade = "B"
    } else if score >= 70 {
        grade = "C"
    } else if score >= 60 {
        grade = "D"
    } else {
        grade = "F"
    }
    
    test_framework.AssertEqual(grade, "B", "Complex if-else-if graded correctly")
}

// Test for loop
數 testForLoop() {
    // Traditional for loop
    let sum = 0
    for i := 0; i < 5; i++ {
        sum += i
    }
    
    test_framework.AssertEqual(sum, 10, "Traditional for loop summed correctly (0+1+2+3+4)")
    
    // For loop with multiple variables
    sum = 0
    for i, j := 0, 10; i < 5; i, j = i+1, j+2 {
        sum += i + j
    }
    
    test_framework.AssertEqual(sum, 60, "For loop with multiple variables")
    
    // Empty sections
    sum = 0
    let i = 0
    for ; i < 5; i++ {
        sum += i
    }
    
    test_framework.AssertEqual(sum, 10, "For loop with empty init section")
    test_framework.AssertEqual(i, 5, "Loop variable visible outside loop")
    
    // All empty
    sum = 0
    i = 0
    for ; i < 5; {
        sum += i
        i++
    }
    
    test_framework.AssertEqual(sum, 10, "For loop with empty init and post sections")
}

// Test for-range loop
數 testForRangeLoop() {
    // Range over array
    let arr = [5]int{1, 2, 3, 4, 5}
    let sum = 0
    
    for i, value := range arr {
        sum += i * value
    }
    
    test_framework.AssertEqual(sum, 40, "Range over array with index and value")
    
    // Range over slice
    let slice = []string{"a", "b", "c"}
    let result = ""
    
    for _, s := range slice {
        result += s
    }
    
    test_framework.AssertEqual(result, "abc", "Range over slice with blank index")
    
    // Range over map
    let m = map[string]int{"a": 1, "b": 2, "c": 3}
    sum = 0
    
    for k, v := range m {
        if k == "b" {
            sum += v * 10
        } else {
            sum += v
        }
    }
    
    test_framework.Assert(sum == 24 || sum == 6, "Range over map") // Order is non-deterministic
    
    // Range over string
    let s = "Hello"
    let counts = make(map[rune]int)
    
    for _, r := range s {
        counts[r]++
    }
    
    test_framework.AssertEqual(counts['H'], 1, "Range over string counted H correctly")
    test_framework.AssertEqual(counts['l'], 2, "Range over string counted l correctly")
}

// Test while-style loop
數 testWhileStyleLoop() {
    // For used as while loop
    let count = 0
    let sum = 0
    
    for count < 5 {
        sum += count
        count++
    }
    
    test_framework.AssertEqual(sum, 10, "While-style loop summed correctly")
    
    // Infinite loop with break
    count = 0
    sum = 0
    
    for {
        if count >= 5 {
            break
        }
        sum += count
        count++
    }
    
    test_framework.AssertEqual(sum, 10, "Infinite loop with break")
}

// Test break statement
數 testBreakStatement() {
    // Break in for loop
    let sum = 0
    
    for i := 0; i < 10; i++ {
        if i > 5 {
            break
        }
        sum += i
    }
    
    test_framework.AssertEqual(sum, 15, "Break stopped the loop at i=6")
    
    // Break in nested loops
    sum = 0
    let done = false
    
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            sum++
            if i == 2 && j == 2 {
                done = true
                break
            }
        }
        if done {
            break
        }
    }
    
    test_framework.AssertEqual(sum, 13, "Break in nested loops")
    
    // Break with label
    sum = 0
    
outer:
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            sum++
            if i == 1 && j == 1 {
                break outer
            }
        }
    }
    
    test_framework.AssertEqual(sum, 7, "Break with label")
}

// Test continue statement
數 testContinueStatement() {
    // Continue in for loop
    let evens = 0
    
    for i := 0; i < 10; i++ {
        if i % 2 == 1 {
            continue
        }
        evens++
    }
    
    test_framework.AssertEqual(evens, 5, "Continue skipped odd numbers")
    
    // Continue in nested loops
    let sum = 0
    
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if j == 1 {
                continue
            }
            sum += i * 3 + j
        }
    }
    
    test_framework.AssertEqual(sum, 12, "Continue in nested loops")
    
    // Continue with label
    sum = 0
    
outer:
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if i == 1 {
                continue outer
            }
            sum += i * 3 + j
        }
    }
    
    test_framework.AssertEqual(sum, 9, "Continue with label")
}

// Test switch statement
數 testSwitchStatement() {
    // Basic switch
    let day = "Wednesday"
    let category = ""
    
    switch day {
    case "Monday":
        category = "start of week"
    case "Tuesday", "Wednesday", "Thursday":
        category = "mid-week"
    case "Friday":
        category = "end of week"
    default:
        category = "weekend"
    }
    
    test_framework.AssertEqual(category, "mid-week", "Switch selected correct case")
    
    // Switch with initialization
    switch x := 42; x % 3 {
    case 0:
        category = "divisible by 3"
    case 1:
        category = "remainder 1"
    case 2:
        category = "remainder 2"
    }
    
    test_framework.AssertEqual(category, "remainder 0", "Switch with initialization")
    
    // Switch without expression (like if-else)
    let score = 85
    
    switch {
    case score >= 90:
        category = "A"
    case score >= 80:
        category = "B"
    case score >= 70:
        category = "C"
    default:
        category = "D or F"
    }
    
    test_framework.AssertEqual(category, "B", "Switch without expression")
}

// Test switch with fallthrough
數 testSwitchWithFallthrough() {
    // Switch with fallthrough
    let value = 2
    let result = 0
    
    switch value {
    case 1:
        result += 1
        fallthrough
    case 2:
        result += 2
        fallthrough
    case 3:
        result += 3
    case 4:
        result += 4
    }
    
    test_framework.AssertEqual(result, 5, "Switch with fallthrough (2+3)")
    
    // Complex fallthrough
    let str = ""
    value = 1
    
    switch value {
    case 0:
        str += "A"
        fallthrough
    case 1:
        str += "B"
        if value == 1 {
            break // Break out of the switch
        }
        fallthrough
    case 2:
        str += "C"
        fallthrough
    default:
        str += "D"
    }
    
    test_framework.AssertEqual(str, "B", "Complex fallthrough with break")
}

// Test type switch
數 testTypeSwitch() {
    // Type switch
    let values := []interface{}{
        42,
        "hello",
        3.14,
        []int{1, 2, 3},
        struct{name string}{"test"},
    }
    
    let counts := map[string]int{
        "int":     0,
        "string":  0,
        "float64": 0,
        "slice":   0,
        "struct":  0,
        "other":   0,
    }
    
    for _, v := range values {
        switch x := v.(type) {
        case int:
            counts["int"]++
            test_framework.AssertEqual(x, 42, "Type switch int value")
        case string:
            counts["string"]++
            test_framework.AssertEqual(x, "hello", "Type switch string value")
        case float64:
            counts["float64"]++
            test_framework.AssertEqual(x, 3.14, "Type switch float64 value")
        case []int:
            counts["slice"]++
            test_framework.AssertEqual(len(x), 3, "Type switch slice length")
        case struct{name string}:
            counts["struct"]++
            test_framework.AssertEqual(x.name, "test", "Type switch struct field")
        default:
            counts["other"]++
        }
    }
    
    test_framework.AssertEqual(counts["int"], 1, "Type switch counted int")
    test_framework.AssertEqual(counts["string"], 1, "Type switch counted string")
    test_framework.AssertEqual(counts["float64"], 1, "Type switch counted float64")
    test_framework.AssertEqual(counts["slice"], 1, "Type switch counted slice")
    test_framework.AssertEqual(counts["struct"], 1, "Type switch counted struct")
    test_framework.AssertEqual(counts["other"], 0, "Type switch counted others")
}

// Test defer statement
數 testDeferStatement() {
    // Basic defer
    let value = getValue()
    test_framework.AssertEqual(value, 42, "Defer executed in LIFO order")
    
    // Multiple defers
    let result = ""
    
    數 multiDefer() string {
        defer func() { result += "1" }()
        defer func() { result += "2" }()
        defer func() { result += "3" }()
        return result
    }
    
    multiDefer()
    test_framework.AssertEqual(result, "321", "Multiple defers executed in LIFO order")
    
    // Defer arguments evaluation
    let x = 1
    
    數 deferArgEval() int {
        defer fmt.Println(x) // Value of x at defer statement (1)
        x = 2
        return x
    }
    
    val := deferArgEval()
    test_framework.AssertEqual(val, 2, "Function returned updated value")
    // The defer should print 1, not 2
    
    // Defer in loops
    let sum = 0
    
    數 deferLoop() {
        for i := 1; i <= 3; i++ {
            defer func(val int) {
                sum += val
            }(i)
        }
    }
    
    deferLoop()
    test_framework.AssertEqual(sum, 6, "Defers in loop captured values correctly (3+2+1)")
}

// Test goto statement
數 testGotoStatement() {
    // Basic goto
    let count = 0
    
start:
    count++
    if count < 3 {
        goto start
    }
    
    test_framework.AssertEqual(count, 3, "Goto looped correct number of times")
    
    // Goto skipping statements
    let result = "before"
    
    goto skip
    result = "skipped" // This should be skipped
    
skip:
    result += " after"
    
    test_framework.AssertEqual(result, "before after", "Goto skipped statements")
    
    // Goto and loops
    count = 0
    let sum = 0
    
loop:
    sum += count
    count++
    if count <= 5 {
        goto loop
    }
    
    test_framework.AssertEqual(sum, 15, "Goto used to implement a loop")
}

// Test nested control flow
數 testNestedControlFlow() {
    // Nested loops
    let result := make([][]int, 3)
    for i := 0; i < 3; i++ {
        result[i] = make([]int, 3)
        for j := 0; j < 3; j++ {
            result[i][j] = i * 3 + j
        }
    }
    
    test_framework.AssertEqual(result[1][1], 4, "Nested loops filled matrix correctly")
    
    // Nested if statements
    let grade := ""
    let score := 85
    let attendance := 95
    
    if score >= 60 {
        if attendance >= 90 {
            grade = "Pass with good attendance"
        } else {
            grade = "Pass with poor attendance"
        }
    } else {
        if attendance >= 90 {
            grade = "Fail with good attendance"
        } else {
            grade = "Fail with poor attendance"
        }
    }
    
    test_framework.AssertEqual(grade, "Pass with good attendance", "Nested if statements categorized correctly")
    
    // Switch inside if
    let category := ""
    let value := 42
    
    if value > 0 {
        switch {
        case value < 10:
            category = "small positive"
        case value < 100:
            category = "medium positive"
        default:
            category = "large positive"
        }
    } else {
        category = "zero or negative"
    }
    
    test_framework.AssertEqual(category, "medium positive", "Switch inside if categorized correctly")
    
    // If inside switch
    let description := ""
    let dayNum := 3 // Wednesday
    
    switch dayNum {
    case 1:
        description = "Monday"
    case 2:
        description = "Tuesday"
    case 3:
        if value < 50 {
            description = "Wednesday (value < 50)"
        } else {
            description = "Wednesday (value >= 50)"
        }
    default:
        description = "Other day"
    }
    
    test_framework.AssertEqual(description, "Wednesday (value < 50)", "If inside switch categorized correctly")
}

// ==================
// Helper functions
// ==================

// Helper function for testing defer
數 getValue() int {
    let result = 0
    
    defer func() {
        result *= 2  // Will be executed last
    }()
    
    defer func() {
        result += 20  // Will be executed second
    }()
    
    defer func() {
        result = 1  // Will be executed first
    }()
    
    return result
}

// Helper function that has a side effect
數 incrementAndCheck(count *int) bool {
    *count++
    return *count > 0
}