// tests/syntax/operators.saika
// Tests for operators and expressions in Saika
package main

import "fmt"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Operators and Expressions")
    
    // Run all test functions
    test_framework.RunTest(testArithmeticOperators, "Arithmetic Operators")
    test_framework.RunTest(testComparisonOperators, "Comparison Operators")
    test_framework.RunTest(testLogicalOperators, "Logical Operators")
    test_framework.RunTest(testBitwiseOperators, "Bitwise Operators")
    test_framework.RunTest(testAssignmentOperators, "Assignment Operators")
    test_framework.RunTest(testIncrementDecrement, "Increment and Decrement")
    test_framework.RunTest(testOperatorPrecedence, "Operator Precedence")
    test_framework.RunTest(testChannelOperators, "Channel Operators")
    test_framework.RunTest(testAddressOperators, "Address and Pointer Operators")
    test_framework.RunTest(testMemberAccessOperators, "Member Access Operators")
    test_framework.RunTest(testFunctionCallsAsExpressions, "Function Calls as Expressions")
    
    // Print test results
    test_framework.PrintResults()
}

// Test arithmetic operators
數 testArithmeticOperators() {
    // Addition
    test_framework.AssertEqual(5 + 3, 8, "Addition of integers")
    test_framework.AssertEqual(5.5 + 3.3, 8.8, "Addition of floats")
    test_framework.AssertEqual("Hello, " + "World!", "Hello, World!", "Addition (concatenation) of strings")
    
    // Subtraction
    test_framework.AssertEqual(10 - 4, 6, "Subtraction of integers")
    test_framework.AssertEqual(5.5 - 3.3, 2.2, "Subtraction of floats")
    
    // Multiplication
    test_framework.AssertEqual(5 * 3, 15, "Multiplication of integers")
    test_framework.AssertEqual(2.5 * 2.0, 5.0, "Multiplication of floats")
    
    // Division
    test_framework.AssertEqual(10 / 2, 5, "Division of integers")
    test_framework.AssertEqual(5.0 / 2.0, 2.5, "Division of floats")
    
    // Integer division
    test_framework.AssertEqual(5 / 2, 2, "Integer division truncates")
    
    // Modulo (remainder)
    test_framework.AssertEqual(10 % 3, 1, "Modulo operation")
    test_framework.AssertEqual(10 % 2, 0, "Modulo with no remainder")
    
    // Unary plus and minus
    test_framework.AssertEqual(+5, 5, "Unary plus")
    test_framework.AssertEqual(-5, -5, "Unary minus")
    
    // Complex arithmetic
    test_framework.AssertEqual((2 + 3) * 4, 20, "Complex arithmetic with parentheses")
    test_framework.AssertEqual(2 + 3 * 4, 14, "Complex arithmetic with precedence")
}

// Test comparison operators
數 testComparisonOperators() {
    // Equal to
    test_framework.Assert(5 == 5, "Equal operator with equal values")
    test_framework.Assert(!(5 == 6), "Equal operator with unequal values")
    
    // Not equal to
    test_framework.Assert(5 != 6, "Not equal operator with unequal values")
    test_framework.Assert(!(5 != 5), "Not equal operator with equal values")
    
    // Less than
    test_framework.Assert(5 < 10, "Less than operator with less value")
    test_framework.Assert(!(10 < 5), "Less than operator with greater value")
    test_framework.Assert(!(5 < 5), "Less than operator with equal values")
    
    // Greater than
    test_framework.Assert(10 > 5, "Greater than operator with greater value")
    test_framework.Assert(!(5 > 10), "Greater than operator with less value")
    test_framework.Assert(!(5 > 5), "Greater than operator with equal values")
    
    // Less than or equal to
    test_framework.Assert(5 <= 10, "Less than or equal operator with less value")
    test_framework.Assert(5 <= 5, "Less than or equal operator with equal values")
    test_framework.Assert(!(10 <= 5), "Less than or equal operator with greater value")
    
    // Greater than or equal to
    test_framework.Assert(10 >= 5, "Greater than or equal operator with greater value")
    test_framework.Assert(5 >= 5, "Greater than or equal operator with equal values")
    test_framework.Assert(!(5 >= 10), "Greater than or equal operator with less value")
    
    // Comparisons with different types
    test_framework.Assert(5 == 5.0, "Equal operator with different numeric types")
    
    // String comparisons
    test_framework.Assert("abc" < "abd", "String comparison with less value")
    test_framework.Assert("abd" > "abc", "String comparison with greater value")
    test_framework.Assert("abc" == "abc", "String comparison with equal values")
    test_framework.Assert("abc" != "abd", "String comparison with unequal values")
}

// Test logical operators
數 testLogicalOperators() {
    // Logical AND
    test_framework.Assert(true && true, "Logical AND with both true")
    test_framework.Assert(!(true && false), "Logical AND with one false")
    test_framework.Assert(!(false && true), "Logical AND with one false")
    test_framework.Assert(!(false && false), "Logical AND with both false")
    
    // Logical OR
    test_framework.Assert(true || true, "Logical OR with both true")
    test_framework.Assert(true || false, "Logical OR with one true")
    test_framework.Assert(false || true, "Logical OR with one true")
    test_framework.Assert(!(false || false), "Logical OR with both false")
    
    // Logical NOT
    test_framework.Assert(!false, "Logical NOT with false")
    test_framework.Assert(!(!true), "Logical NOT with true")
    
    // Short-circuit evaluation
    let x := 0
    let evaluated := false
    
    // Short-circuit AND - second expression won't be evaluated if first is false
    if false && func() bool { evaluated = true; return true }() {
        test_framework.Assert(false, "Should not reach here")
    }
    test_framework.Assert(!evaluated, "Second expression not evaluated in AND")
    
    evaluated = false
    // Short-circuit OR - second expression won't be evaluated if first is true
    if true || func() bool { evaluated = true; return true }() {
        // Should reach here
    }
    test_framework.Assert(!evaluated, "Second expression not evaluated in OR")
    
    // Complex logical expressions
    test_framework.Assert((true && !false) || (false && true), "Complex logical expression")
    test_framework.Assert(!(false || (true && false)), "Complex logical expression with NOT")
}

// Test bitwise operators
數 testBitwiseOperators() {
    // Bitwise AND
    test_framework.AssertEqual(0b1100 & 0b1010, 0b1000, "Bitwise AND")
    
    // Bitwise OR
    test_framework.AssertEqual(0b1100 | 0b1010, 0b1110, "Bitwise OR")
    
    // Bitwise XOR
    test_framework.AssertEqual(0b1100 ^ 0b1010, 0b0110, "Bitwise XOR")
    
    // Bitwise NOT
    test_framework.AssertEqual(^0b00001111, -16, "Bitwise NOT")
    
    // Left shift
    test_framework.AssertEqual(0b0001 << 2, 0b0100, "Left shift")
    
    // Right shift
    test_framework.AssertEqual(0b1000 >> 2, 0b0010, "Right shift")
    
    // Unsigned right shift (same as normal right shift for positive numbers)
    test_framework.AssertEqual(0b1000 >> 2, 0b0010, "Unsigned right shift")
    
    // Bitshift on negative numbers
    test_framework.AssertEqual(-8 >> 2, -2, "Right shift preserves sign")
    
    // Bitwise clear (AND NOT) - Only in Go, not in many other languages
    test_framework.AssertEqual(0b1100 &^ 0b1010, 0b0100, "Bitwise AND NOT")
}

// Test assignment operators
數 testAssignmentOperators() {
    // Simple assignment
    let a = 5
    test_framework.AssertEqual(a, 5, "Simple assignment")
    
    // Addition assignment
    let b = 5
    b += 3
    test_framework.AssertEqual(b, 8, "Addition assignment")
    
    // Subtraction assignment
    let c = 5
    c -= 3
    test_framework.AssertEqual(c, 2, "Subtraction assignment")
    
    // Multiplication assignment
    let d = 5
    d *= 3
    test_framework.AssertEqual(d, 15, "Multiplication assignment")
    
    // Division assignment
    let e = 6
    e /= 2
    test_framework.AssertEqual(e, 3, "Division assignment")
    
    // Modulo assignment
    let f = 7
    f %= 3
    test_framework.AssertEqual(f, 1, "Modulo assignment")
    
    // Bitwise AND assignment
    let g = 0b1100
    g &= 0b1010
    test_framework.AssertEqual(g, 0b1000, "Bitwise AND assignment")
    
    // Bitwise OR assignment
    let h = 0b1100
    h |= 0b1010
    test_framework.AssertEqual(h, 0b1110, "Bitwise OR assignment")
    
    // Bitwise XOR assignment
    let i = 0b1100
    i ^= 0b1010
    test_framework.AssertEqual(i, 0b0110, "Bitwise XOR assignment")
    
    // Left shift assignment
    let j = 0b0001
    j <<= 2
    test_framework.AssertEqual(j, 0b0100, "Left shift assignment")
    
    // Right shift assignment
    let k = 0b1000
    k >>= 2
    test_framework.AssertEqual(k, 0b0010, "Right shift assignment")
    
    // Bitwise clear assignment
    let l = 0b1100
    l &^= 0b1010
    test_framework.AssertEqual(l, 0b0100, "Bitwise clear assignment")
    
    // Multiple assignments
    let m, n = 5, 10
    test_framework.AssertEqual(m, 5, "Multiple assignment - first value")
    test_framework.AssertEqual(n, 10, "Multiple assignment - second value")
    
    // Swap values using multiple assignment
    m, n = n, m
    test_framework.AssertEqual(m, 10, "Swapped first value")
    test_framework.AssertEqual(n, 5, "Swapped second value")
}

// Test increment and decrement operators
數 testIncrementDecrement() {
    // Increment
    let a = 5
    a++
    test_framework.AssertEqual(a, 6, "Increment operator")
    
    // Decrement
    let b = 5
    b--
    test_framework.AssertEqual(b, 4, "Decrement operator")
    
    // Post-increment
    let c = 5
    let d = c++  // In Go/Saika, this is invalid; ++ and -- are statements, not expressions
    test_framework.AssertEqual(c, 6, "Value after post-increment")
    test_framework.AssertEqual(d, 5, "Post-increment returns original value")
    
    // Post-decrement
    let e = 5
    let f = e--  // In Go/Saika, this is invalid; ++ and -- are statements, not expressions
    test_framework.AssertEqual(e, 4, "Value after post-decrement")
    test_framework.AssertEqual(f, 5, "Post-decrement returns original value")
    
    // Multiple increments
    let g = 5
    g++
    g++
    test_framework.AssertEqual(g, 7, "Multiple increments")
    
    // Increment and decrement
    let h = 5
    h++
    h--
    test_framework.AssertEqual(h, 5, "Increment and decrement cancel out")
}

// Test operator precedence
數 testOperatorPrecedence() {
    // Arithmetic operators precedence
    test_framework.AssertEqual(2 + 3 * 4, 14, "Multiplication has higher precedence than addition")
    test_framework.AssertEqual(2 * 3 + 4, 10, "Multiplication has higher precedence than addition")
    test_framework.AssertEqual(10 - 4 / 2, 8, "Division has higher precedence than subtraction")
    test_framework.AssertEqual(10 / 2 - 3, 2, "Division has higher precedence than subtraction")
    
    // Parentheses override precedence
    test_framework.AssertEqual((2 + 3) * 4, 20, "Parentheses override operator precedence")
    test_framework.AssertEqual(2 * (3 + 4), 14, "Parentheses override operator precedence")
    
    // Bitwise operators precedence
    test_framework.AssertEqual(1 | 2 & 3, 3, "Bitwise AND has higher precedence than bitwise OR")
    test_framework.AssertEqual(1 & 2 | 3, 3, "Bitwise AND has higher precedence than bitwise OR")
    
    // Comparison and logical operators precedence
    test_framework.Assert(5 > 3 && 2 < 4, "Comparison operators have higher precedence than logical operators")
    test_framework.Assert(!(5 > 3 && 2 > 4), "Logical NOT has higher precedence than logical AND")
    
    // Complex expressions
    test_framework.AssertEqual(2 * 3 + 4 * 5, 26, "Complex expression with arithmetic operators")
    test_framework.Assert(5 > 3 && 2 < 4 || 6 > 7, "Complex expression with comparison and logical operators")
    test_framework.AssertEqual((2 + 3) * (4 + 5), 45, "Complex expression with parentheses")
}

// Test channel operators
數 testChannelOperators() {
    // Create buffered channels
    ch1 := make(chan int, 1)
    ch2 := make(chan int, 1)
    
    // Send operation
    ch1 <- 42  // Send 42 to channel
    
    // Receive operation
    val := <-ch1  // Receive from channel
    test_framework.AssertEqual(val, 42, "Channel send and receive")
    
    // Select statement with channels
    ch2 <- 10
    
    select {
    case val1 := <-ch1:
        test_framework.Assert(false, "Should not receive from empty channel")
    case val2 := <-ch2:
        test_framework.AssertEqual(val2, 10, "Received from second channel")
    default:
        test_framework.Assert(false, "Should not reach default case")
    }
    
    // Non-blocking send operation
    select {
    case ch1 <- 5:
        test_framework.Assert(true, "Non-blocking send succeeded")
    default:
        test_framework.Assert(false, "Non-blocking send should succeed")
    }
    
    // Non-blocking receive operation
    select {
    case val3 := <-ch1:
        test_framework.AssertEqual(val3, 5, "Non-blocking receive succeeded")
    default:
        test_framework.Assert(false, "Non-blocking receive should succeed")
    }
    
    // Closing a channel
    close(ch1)
    
    // Receiving from closed channel
    val4, ok := <-ch1
    test_framework.Assert(!ok, "Channel is closed")
    test_framework.AssertEqual(val4, 0, "Receive from closed channel returns zero value")
}

// Test address and pointer operators
數 testAddressOperators() {
    // Address-of operator
    let x = 42
    let p = &x  // Get address of x
    test_framework.Assert(p != nil, "Address-of operator returns non-nil pointer")
    
    // Dereference operator
    test_framework.AssertEqual(*p, 42, "Dereference operator returns value")
    
    // Modifying through pointer
    *p = 24
    test_framework.AssertEqual(x, 24, "Value modified through pointer")
    
    // Address of array element
    let arr = [3]int{1, 2, 3}
    let p2 = &arr[1]
    test_framework.AssertEqual(*p2, 2, "Address of array element")
    
    // Modify array element through pointer
    *p2 = 20
    test_framework.AssertEqual(arr[1], 20, "Array element modified through pointer")
    
    // Address of struct field
    let s = struct {
        name string
        age  int
    }{"John", 30}
    
    let pAge = &s.age
    test_framework.AssertEqual(*pAge, 30, "Address of struct field")
    
    // Modify struct field through pointer
    *pAge = 31
    test_framework.AssertEqual(s.age, 31, "Struct field modified through pointer")
}

// Test member access operators
數 testMemberAccessOperators() {
    // Struct field access
    let person = Person{
        name: "John",
        age:  30,
    }
    
    test_framework.AssertEqual(person.name, "John", "Struct field access")
    test_framework.AssertEqual(person.age, 30, "Struct field access")
    
    // Nested struct field access
    let employee = Employee{
        person: person,
        salary: 50000,
    }
    
    test_framework.AssertEqual(employee.person.name, "John", "Nested struct field access")
    
    // Embedded struct field access
    let manager = Manager{
        Person: person,
        department: "IT",
    }
    
    test_framework.AssertEqual(manager.name, "John", "Embedded struct field access")
    test_framework.AssertEqual(manager.Person.age, 30, "Explicit embedded struct field access")
    
    // Pointer to struct field access
    let p = &person
    test_framework.AssertEqual(p.name, "John", "Pointer to struct field access")
    
    // Automatic dereferencing
    p.age = 31
    test_framework.AssertEqual(person.age, 31, "Struct field modified through pointer")
    
    // Array index access
    let arr = [3]int{1, 2, 3}
    test_framework.AssertEqual(arr[0], 1, "Array index access")
    test_framework.AssertEqual(arr[2], 3, "Array index access")
    
    // Slice index access
    let slice = []int{4, 5, 6}
    test_framework.AssertEqual(slice[1], 5, "Slice index access")
    
    // Map key access
    let m = map[string]int{"a": 1, "b": 2, "c": 3}
    test_framework.AssertEqual(m["b"], 2, "Map key access")
    
    // Map key access with comma ok
    val, ok := m["d"]
    test_framework.Assert(!ok, "Map key not found")
    test_framework.AssertEqual(val, 0, "Default value for nonexistent map key")
}

// Test function calls as expressions
數 testFunctionCallsAsExpressions() {
    // Simple function call
    test_framework.AssertEqual(add(2, 3), 5, "Function call as expression")
    
    // Nested function calls
    test_framework.AssertEqual(add(multiply(2, 3), 4), 10, "Nested function calls")
    
    // Function call with function call arguments
    test_framework.AssertEqual(multiply(add(1, 2), add(3, 4)), 21, "Function call with function call arguments")
    
    // Method call
    let p = Person{name: "John", age: 30}
    test_framework.AssertEqual(p.getNameLength(), 4, "Method call as expression")
    
    // Method call used in expression
    test_framework.AssertEqual(p.getNameLength() * 2, 8, "Method call used in expression")
    
    // Function call with side effects
    let count = 0
    let result = incrementAndReturn(&count, 5)
    test_framework.AssertEqual(result, 5, "Function call with side effects - return value")
    test_framework.AssertEqual(count, 1, "Function call with side effects - modified variable")
    
    // Function that returns multiple values
    let val, err := divideWithError(10, 2)
    test_framework.AssertEqual(val, 5, "Function returns multiple values - result")
    test_framework.Assert(err == nil, "Function returns multiple values - no error")
    
    // Function assigned to variable
    let fn = add
    test_framework.AssertEqual(fn(5, 7), 12, "Function assigned to variable")
    
    // Anonymous function call
    test_framework.AssertEqual(func(x, y int) int { return x - y }(10, 3), 7, "Anonymous function call")
}

// ==================
// Helper types and functions
// ==================

// Person struct for testing member access operators
struct Person {
    name string
    age  int
}

// Method for Person
數 (p Person) getNameLength() int {
    return len(p.name)
}

// Employee struct with nested Person
struct Employee {
    person Person
    salary int
}

// Manager struct with embedded Person
struct Manager {
    Person
    department string
}

// Add two numbers
數 add(a, b int) int {
    return a + b
}

// Multiply two numbers
數 multiply(a, b int) int {
    return a * b
}

// Increment a counter and return a value
數 incrementAndReturn(counter *int, value int) int {
    *counter++
    return value
}

// Divide with possible error
數 divideWithError(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}