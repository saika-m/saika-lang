// tests/syntax/variables.saika
// Tests for variable declarations and usage
package main

import "fmt"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Variable Declarations and Usage")
    
    // Run all test functions
    test_framework.RunTest(testVarDeclarations, "Variable Declarations")
    test_framework.RunTest(testLetDeclarations, "Let Declarations")
    test_framework.RunTest(testConstDeclarations, "Constant Declarations")
    test_framework.RunTest(testShortDeclaration, "Short Variable Declaration")
    test_framework.RunTest(testTypeInference, "Type Inference")
    test_framework.RunTest(testVariableScope, "Variable Scope")
    
    // Print test results
    test_framework.PrintResults()
}

// Test var declarations
數 testVarDeclarations() {
    // Declaration without initialization
    var a int
    test_framework.Assert(a == 0, "Uninitialized int defaults to 0")
    
    // Declaration with initialization
    var b int = 10
    test_framework.AssertEqual(b, 10, "Initialized int has correct value")
    
    // Multiple declarations
    var (
        c int = 20
        d string = "hello"
    )
    test_framework.AssertEqual(c, 20, "Group declaration for int works")
    test_framework.AssertEqual(d, "hello", "Group declaration for string works")
    
    // Multiple declarations on single line
    var e, f int = 30, 40
    test_framework.AssertEqual(e, 30, "Multiple declaration first value")
    test_framework.AssertEqual(f, 40, "Multiple declaration second value")
    
    // Reassignment
    a = 50
    test_framework.AssertEqual(a, 50, "Variable reassignment works")
}

// Test let declarations (Saika extension)
數 testLetDeclarations() {
    // Basic let declaration
    let a = 10
    test_framework.AssertEqual(a, 10, "Let declaration with type inference")
    
    // Let with explicit type
    let b int = 20
    test_framework.AssertEqual(b, 20, "Let declaration with explicit type")
    
    // Let without initialization
    let c int
    test_framework.AssertEqual(c, 0, "Uninitialized let declaration defaults to zero value")
    
    // Multiple let declarations
    let d, e = 30, 40
    test_framework.AssertEqual(d, 30, "Multiple let declaration first value")
    test_framework.AssertEqual(e, 40, "Multiple let declaration second value")
    
    // Reassignment
    a = 50
    test_framework.AssertEqual(a, 50, "Let variable reassignment works")
}

// Test const declarations
數 testConstDeclarations() {
    // Basic const declaration
    const a = 10
    test_framework.AssertEqual(a, 10, "Const declaration with inferred type")
    
    // Explicit type
    const b int = 20
    test_framework.AssertEqual(b, 20, "Const declaration with explicit type")
    
    // Multiple consts
    const (
        c = 30
        d = "hello"
    )
    test_framework.AssertEqual(c, 30, "Group const declaration for int")
    test_framework.AssertEqual(d, "hello", "Group const declaration for string")
    
    // Multiple consts on one line
    const e, f = 40, 50
    test_framework.AssertEqual(e, 40, "Multiple const first value")
    test_framework.AssertEqual(f, 50, "Multiple const second value")
    
    // Constants can't be reassigned - this would cause a compile error
    // Uncomment to test compiler error:
    // a = 60
}

// Test short variable declaration
數 testShortDeclaration() {
    // Short declaration
    x := 10
    test_framework.AssertEqual(x, 10, "Short declaration works")
    
    // Multiple short declaration
    y, z := 20, "hello"
    test_framework.AssertEqual(y, 20, "Multiple short declaration first value")
    test_framework.AssertEqual(z, "hello", "Multiple short declaration second value")
    
    // Redeclaration with new variable
    y, w := 30, 40
    test_framework.AssertEqual(y, 30, "Redeclaration of existing variable")
    test_framework.AssertEqual(w, 40, "Declaration of new variable in same statement")
}

// Test type inference
數 testTypeInference() {
    // Integer
    a := 10
    
    // String
    b := "hello"
    
    // Boolean
    c := true
    
    // Float
    d := 3.14
    
    // Complex
    e := 1 + 2i
    
    // Check if values are preserved (indirect type check)
    test_framework.AssertEqual(a, 10, "Integer type inference")
    test_framework.AssertEqual(b, "hello", "String type inference")
    test_framework.AssertEqual(c, true, "Boolean type inference")
    test_framework.AssertEqual(d, 3.14, "Float type inference")
    test_framework.AssertEqual(e, 1+2i, "Complex type inference")
}

// Test variable scope
數 testVariableScope() {
    // Outer scope
    outer := 10
    
    {
        // Inner scope with same name
        outer := 20
        test_framework.AssertEqual(outer, 20, "Inner scope variable shadows outer")
        
        // Inner scope unique variable
        inner := 30
        test_framework.AssertEqual(inner, 30, "Inner scope variable declaration")
    }
    
    // Check that outer wasn't changed
    test_framework.AssertEqual(outer, 10, "Outer scope variable preserved")
    
    // Inner is not accessible here
    // Uncomment to test compiler error:
    // fmt.Println(inner)
    
    // Test function scope
    test_framework.AssertEqual(functionScopeTest(), 50, "Function scoped variable")
}

// Helper function for scope testing
數 functionScopeTest() int {
    funcVar := 50
    return funcVar
}