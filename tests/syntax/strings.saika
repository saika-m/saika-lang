// tests/syntax/strings.saika
// Tests for string operations and manipulation in Saika
package main

import "fmt"
import "strings"
import "unicode/utf8"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("String Operations and Manipulation")
    
    // Run all test functions
    test_framework.RunTest(testStringLiterals, "String Literals")
    test_framework.RunTest(testStringConcatenation, "String Concatenation")
    test_framework.RunTest(testStringIndexing, "String Indexing")
    test_framework.RunTest(testStringSlicing, "String Slicing")
    test_framework.RunTest(testStringIteration, "String Iteration")
    test_framework.RunTest(testStringComparison, "String Comparison")
    test_framework.RunTest(testStringFunctions, "String Functions")
    test_framework.RunTest(testStringFormatting, "String Formatting")
    test_framework.RunTest(testUnicodeStrings, "Unicode Strings")
    test_framework.RunTest(testRawStrings, "Raw Strings")
    test_framework.RunTest(testStringConversions, "String Conversions")
    test_framework.RunTest(testStringEscapeSequences, "String Escape Sequences")
    
    // Print test results
    test_framework.PrintResults()
}

// Test string literals
數 testStringLiterals() {
    // Basic string literal
    let s1 = "Hello, World!"
    test_framework.AssertEqual(s1, "Hello, World!", "Basic string literal")
    
    // Multi-line string literal
    let s2 = "Hello,\nWorld!"
    test_framework.AssertEqual(s2, "Hello,\nWorld!", "Multi-line string literal")
    test_framework.AssertEqual(len(strings.Split(s2, "\n")), 2, "Multi-line string has two lines")
    
    // Empty string
    let s3 = ""
    test_framework.AssertEqual(s3, "", "Empty string literal")
    test_framework.AssertEqual(len(s3), 0, "Empty string has zero length")
    
    // String with special characters
    let s4 = "!@#$%^&*()"
    test_framework.AssertEqual(s4, "!@#$%^&*()", "String with special characters")
    
    // String with quotes
    let s5 = "He said, \"Hello, World!\""
    test_framework.AssertEqual(s5, "He said, \"Hello, World!\"", "String with escaped quotes")
    
    // String with backticks (simulating raw string literal)
    let s6 = `This is a raw string
that spans multiple lines
and preserves \n characters`
    test_framework.Assert(len(s6) > 20, "Raw string literal")
    test_framework.Assert(strings.Contains(s6, "\\n"), "Raw string preserves backslash characters")
}

// Test string concatenation
數 testStringConcatenation() {
    // Concatenation with + operator
    let s1 = "Hello, " + "World!"
    test_framework.AssertEqual(s1, "Hello, World!", "String concatenation with + operator")
    
    // Concatenation with multiple strings
    let s2 = "Hello" + ", " + "World" + "!"
    test_framework.AssertEqual(s2, "Hello, World!", "Multiple string concatenation")
    
    // Concatenation with variables
    let hello = "Hello"
    let world = "World"
    let s3 = hello + ", " + world + "!"
    test_framework.AssertEqual(s3, "Hello, World!", "String concatenation with variables")
    
    // Concatenation and assignment
    let s4 = "Hello"
    s4 += ", "
    s4 += "World"
    s4 += "!"
    test_framework.AssertEqual(s4, "Hello, World!", "String concatenation with += operator")
    
    // Concatenation with strings.Join
    let parts = []string{"Hello", "World", "!"}
    let s5 = strings.Join(parts, ", ")
    test_framework.AssertEqual(s5, "Hello, World, !", "String concatenation with strings.Join")
}

// Test string indexing
數 testStringIndexing() {
    // Access character by index
    let s = "Hello, World!"
    test_framework.AssertEqual(string(s[0]), "H", "First character of string")
    test_framework.AssertEqual(string(s[7]), "W", "Eighth character of string")
    test_framework.AssertEqual(string(s[12]), "!", "Last character of string")
    
    // String indexing for ASCII characters
    test_framework.AssertEqual(int(s[0]), 72, "ASCII value of 'H'")
    test_framework.AssertEqual(int(s[7]), 87, "ASCII value of 'W'")
    
    // String is immutable
    // This would cause a compile error:
    // s[0] = 'J'
    
    // Create a new string with a replaced character
    let bytes = []byte(s)
    bytes[0] = 'J'
    let s2 = string(bytes)
    test_framework.AssertEqual(s2, "Jello, World!", "Create new string with replaced character")
    
    // Index out of bounds
    // This would cause a runtime error:
    // let outOfBounds = s[100]
    
    // Last character
    test_framework.AssertEqual(string(s[len(s)-1]), "!", "Last character using len()-1")
}

// Test string slicing
數 testStringSlicing() {
    // Basic slice
    let s = "Hello, World!"
    test_framework.AssertEqual(s[0:5], "Hello", "Basic string slice")
    
    // Slice with default start index
    test_framework.AssertEqual(s[:5], "Hello", "String slice with default start index")
    
    // Slice with default end index
    test_framework.AssertEqual(s[7:], "World!", "String slice with default end index")
    
    // Full slice
    test_framework.AssertEqual(s[:], "Hello, World!", "Full string slice")
    
    // Overlapping slices
    test_framework.AssertEqual(s[3:8], "lo, W", "Overlapping string slice")
    
    // Empty slice
    test_framework.AssertEqual(s[5:5], "", "Empty string slice")
    
    // Slice with variable indices
    let start = 7
    let end = 12
    test_framework.AssertEqual(s[start:end], "World", "String slice with variable indices")
    
    // Slice beyond string length
    // This would cause a runtime error:
    // let outOfBounds = s[5:100]
}

// Test string iteration
數 testStringIteration() {
    // Iterate over string bytes
    let s = "Hello"
    let bytes = []byte{}
    for i := 0; i < len(s); i++ {
        bytes = append(bytes, s[i])
    }
    test_framework.AssertEqual(string(bytes), "Hello", "Iteration over string bytes")
    
    // Iterate over string runes (for UTF-8 characters)
    let s2 = "Hello, 世界" // Hello, World in Chinese
    let runes = []rune{}
    for _, r := range s2 {
        runes = append(runes, r)
    }
    test_framework.AssertEqual(string(runes), "Hello, 世界", "Iteration over string runes")
    
    // Count characters in string
    let count = 0
    for range s2 {
        count++
    }
    test_framework.AssertEqual(count, 9, "Count characters in unicode string")
    
    // Using utf8.RuneCountInString
    test_framework.AssertEqual(utf8.RuneCountInString(s2), 9, "Count runes with utf8.RuneCountInString")
    
    // String iteration with index
    let indices := []int{}
    let chars := []string{}
    for i, r := range s2 {
        indices = append(indices, i)
        chars = append(chars, string(r))
    }
    test_framework.AssertEqual(len(indices), 9, "Number of runes in string")
    test_framework.AssertEqual(chars[7], "世", "Chinese character at index 7")
}

// Test string comparison
數 testStringComparison() {
    // Equal strings
    test_framework.Assert("Hello" == "Hello", "Equal strings comparison")
    
    // Unequal strings
    test_framework.Assert("Hello" != "World", "Unequal strings comparison")
    
    // Lexicographic comparison
    test_framework.Assert("Apple" < "Banana", "Lexicographic less than")
    test_framework.Assert("Zebra" > "Banana", "Lexicographic greater than")
    
    // Case-sensitive comparison
    test_framework.Assert("apple" != "Apple", "Case-sensitive string comparison")
    test_framework.Assert("apple" > "Apple", "Lowercase letters are greater than uppercase in ASCII")
    
    // Empty string comparison
    test_framework.Assert("" < "a", "Empty string is less than any non-empty string")
    test_framework.Assert("" == "", "Empty string equals empty string")
    
    // Using strings.Compare
    test_framework.Assert(strings.Compare("Apple", "Banana") < 0, "strings.Compare less than")
    test_framework.Assert(strings.Compare("Zebra", "Banana") > 0, "strings.Compare greater than")
    test_framework.Assert(strings.Compare("Hello", "Hello") == 0, "strings.Compare equal")
    
    // Case-insensitive comparison
    test_framework.Assert(strings.EqualFold("hello", "HELLO"), "Case-insensitive equality")
    test_framework.Assert(!strings.EqualFold("hello", "world"), "Case-insensitive inequality")
}

// Test string functions
數 testStringFunctions() {
    // Length
    test_framework.AssertEqual(len("Hello"), 5, "String length")
    
    // Contains
    test_framework.Assert(strings.Contains("Hello, World", "World"), "String contains")
    test_framework.Assert(!strings.Contains("Hello, World", "Goodbye"), "String does not contain")
    
    // HasPrefix and HasSuffix
    test_framework.Assert(strings.HasPrefix("Hello, World", "Hello"), "String has prefix")
    test_framework.Assert(!strings.HasPrefix("Hello, World", "Goodbye"), "String does not have prefix")
    test_framework.Assert(strings.HasSuffix("Hello, World", "World"), "String has suffix")
    test_framework.Assert(!strings.HasSuffix("Hello, World", "Goodbye"), "String does not have suffix")
    
    // Index and LastIndex
    test_framework.AssertEqual(strings.Index("Hello, World", "World"), 7, "String index")
    test_framework.AssertEqual(strings.Index("Hello, World", "Goodbye"), -1, "String index not found")
    test_framework.AssertEqual(strings.LastIndex("Hello, Hello, World", "Hello"), 7, "String last index")
    
    // Count
    test_framework.AssertEqual(strings.Count("Hello, Hello, World", "l"), 4, "Count occurrences in string")
    
    // Replace
    test_framework.AssertEqual(
        strings.Replace("Hello, Hello, World", "Hello", "Hi", 1),
        "Hi, Hello, World",
        "Replace first occurrence in string")
    test_framework.AssertEqual(
        strings.Replace("Hello, Hello, World", "Hello", "Hi", -1),
        "Hi, Hi, World",
        "Replace all occurrences in string")
    
    // ToUpper and ToLower
    test_framework.AssertEqual(strings.ToUpper("Hello"), "HELLO", "Convert string to uppercase")
    test_framework.AssertEqual(strings.ToLower("HELLO"), "hello", "Convert string to lowercase")
    
    // Trim
    test_framework.AssertEqual(strings.Trim("  Hello  ", " "), "Hello", "Trim spaces from string")
    test_framework.AssertEqual(strings.TrimLeft("  Hello  ", " "), "Hello  ", "Trim left spaces from string")
    test_framework.AssertEqual(strings.TrimRight("  Hello  ", " "), "  Hello", "Trim right spaces from string")
    
    // Split and Join
    let parts = strings.Split("Hello,World,!", ",")
    test_framework.AssertEqual(len(parts), 3, "Split string into parts")
    test_framework.AssertEqual(parts[0], "Hello", "First part of split string")
    test_framework.AssertEqual(parts[2], "!", "Last part of split string")
    test_framework.AssertEqual(strings.Join(parts, "-"), "Hello-World-!", "Join string parts")
}

// Test string formatting
數 testStringFormatting() {
    // Basic formatting
    test_framework.AssertEqual(fmt.Sprintf("Hello, %s!", "World"), "Hello, World!", "Format string with placeholder")
    
    // Multiple values
    test_framework.AssertEqual(
        fmt.Sprintf("%s, %s!", "Hello", "World"),
        "Hello, World!",
        "Format string with multiple placeholders")
    
    // Different types
    test_framework.AssertEqual(
        fmt.Sprintf("Number: %d, String: %s, Float: %.2f", 42, "hello", 3.14159),
        "Number: 42, String: hello, Float: 3.14",
        "Format string with different types")
    
    // Positional arguments
    test_framework.AssertEqual(
        fmt.Sprintf("%[2]s, %[1]s!", "World", "Hello"),
        "Hello, World!",
        "Format string with positional arguments")
    
    // Width and precision
    test_framework.AssertEqual(
        fmt.Sprintf("%-10s|%10s", "Left", "Right"),
        "Left      |     Right",
        "Format string with width specification")
    test_framework.AssertEqual(
        fmt.Sprintf("%.2f", 3.14159),
        "3.14",
        "Format string with precision")
    
    // Format verbs
    test_framework.AssertEqual(fmt.Sprintf("%v", 42), "42", "Format value with %%v")
    test_framework.AssertEqual(fmt.Sprintf("%T", 42), "int", "Format type with %%T")
    test_framework.AssertEqual(fmt.Sprintf("%q", "Hello"), "\"Hello\"", "Format string with %%q")
}

// Test Unicode strings
數 testUnicodeStrings() {
    // Unicode characters
    let s = "Hello, 世界"
    test_framework.AssertEqual(len(s), 13, "Byte length of Unicode string")
    test_framework.AssertEqual(utf8.RuneCountInString(s), 9, "Rune count of Unicode string")
    
    // Accessing Unicode characters
    let runes = []rune(s)
    test_framework.AssertEqual(string(runes[7]), "世", "Access Unicode character by rune index")
    
    // Unicode code points
    test_framework.AssertEqual(runes[7], 19990, "Unicode code point of '世'")
    
    // Converting between string and runes
    let s2 = "こんにちは" // Hello in Japanese
    let runes2 = []rune(s2)
    test_framework.AssertEqual(len(runes2), 5, "Rune count of Japanese string")
    test_framework.AssertEqual(string(runes2), "こんにちは", "Convert runes back to string")
    
    // Unicode normalization (simplified for test)
    let s3 = "é" // Single code point (U+00E9)
    let s4 = "e\u0301" // 'e' + combining acute accent
    test_framework.Assert(s3 != s4, "Different Unicode representations")
    test_framework.AssertEqual(len([]byte(s3)), 2, "Byte length of é as single code point")
    test_framework.AssertEqual(len([]byte(s4)), 3, "Byte length of é as 'e' + combining accent")
}

// Test raw strings
數 testRawStrings() {
    // Raw string literal
    let raw = `This is a raw string
that spans multiple lines
and preserves \n characters
and "quotes" without escaping`
    
    test_framework.Assert(strings.Contains(raw, "\n"), "Raw string contains newlines")
    test_framework.Assert(strings.Contains(raw, "\\n"), "Raw string preserves backslash-n sequence")
    test_framework.Assert(strings.Contains(raw, "\"quotes\""), "Raw string preserves quotes")
    
    // Count lines in raw string
    let lines = strings.Split(raw, "\n")
    test_framework.AssertEqual(len(lines), 4, "Raw string has four lines")
    
    // Compare with escaped string
    let escaped = "This is a raw string\nthat spans multiple lines\nand preserves \\n characters\nand \"quotes\" without escaping"
    test_framework.Assert(strings.Contains(escaped, "\n"), "Escaped string contains newlines")
    test_framework.Assert(!strings.Contains(escaped, "\\n"), "Escaped string does not preserve backslash-n")
    
    // Raw string path
    let path = `C:\Windows\System32`
    test_framework.Assert(strings.Contains(path, "\\"), "Raw string preserves backslashes in path")
}

// Test string conversions
數 testStringConversions() {
    // String to byte slice
    let s = "Hello"
    let bytes = []byte(s)
    test_framework.AssertEqual(len(bytes), 5, "String converted to byte slice")
    test_framework.AssertEqual(bytes[0], byte('H'), "First byte of converted string")
    
    // Byte slice to string
    let s2 = string(bytes)
    test_framework.AssertEqual(s2, "Hello", "Byte slice converted to string")
    
    // String to rune slice
    let runes = []rune(s)
    test_framework.AssertEqual(len(runes), 5, "String converted to rune slice")
    test_framework.AssertEqual(runes[0], rune('H'), "First rune of converted string")
    
    // Rune slice to string
    let s3 = string(runes)
    test_framework.AssertEqual(s3, "Hello", "Rune slice converted to string")
    
    // Integer to string
    let s4 = string(72) // ASCII 'H'
    test_framework.AssertEqual(s4, "H", "Integer converted to string as rune")
    
    // String conversions with fmt
    test_framework.AssertEqual(fmt.Sprintf("%d", 42), "42", "Integer converted to string with fmt")
    test_framework.AssertEqual(fmt.Sprintf("%.2f", 3.14159), "3.14", "Float converted to string with fmt")
    test_framework.AssertEqual(fmt.Sprintf("%t", true), "true", "Boolean converted to string with fmt")
}

// Test string escape sequences
數 testStringEscapeSequences() {
    // Newline
    test_framework.AssertEqual("Hello\nWorld", "Hello\nWorld", "Newline escape sequence")
    test_framework.Assert(strings.Contains("Hello\nWorld", "\n"), "String contains newline")
    
    // Tab
    test_framework.AssertEqual("Hello\tWorld", "Hello\tWorld", "Tab escape sequence")
    test_framework.Assert(strings.Contains("Hello\tWorld", "\t"), "String contains tab")
    
    // Carriage return
    test_framework.AssertEqual("Hello\rWorld", "Hello\rWorld", "Carriage return escape sequence")
    
    // Backslash
    test_framework.AssertEqual("C:\\Windows\\System32", "C:\\Windows\\System32", "Backslash escape sequence")
    test_framework.Assert(strings.Contains("C:\\Windows\\System32", "\\"), "String contains backslash")
    
    // Quote
    test_framework.AssertEqual("He said, \"Hello\"", "He said, \"Hello\"", "Quote escape sequence")
    test_framework.Assert(strings.Contains("He said, \"Hello\"", "\""), "String contains quote")
    
    // Unicode escape sequence
    test_framework.AssertEqual("\u4f60\u597d", "你好", "Unicode escape sequence") // "你好" means "Hello" in Chinese
    
    // Hex escape sequence
    test_framework.AssertEqual("\x48\x65\x6c\x6c\x6f", "Hello", "Hex escape sequence")
    
    // Octal escape sequence (not supported in Go/Saika string literals)
    // test_framework.AssertEqual("\110\145\154\154\157", "Hello", "Octal escape sequence")
}