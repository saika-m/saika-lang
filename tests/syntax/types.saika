// tests/syntax/types.saika
// Tests for type declarations and usage in Saika
package main

import "fmt"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Type Declarations and Usage")
    
    // Run all test functions
    test_framework.RunTest(testBasicTypes, "Basic Types")
    test_framework.RunTest(testArrayTypes, "Array Types")
    test_framework.RunTest(testSliceTypes, "Slice Types")
    test_framework.RunTest(testMapTypes, "Map Types")
    test_framework.RunTest(testStructTypes, "Struct Types")
    test_framework.RunTest(testInterfaceTypes, "Interface Types")
    test_framework.RunTest(testFunctionTypes, "Function Types")
    test_framework.RunTest(testChannelTypes, "Channel Types")
    test_framework.RunTest(testPointerTypes, "Pointer Types")
    test_framework.RunTest(testTypeAliases, "Type Aliases")
    test_framework.RunTest(testTypeDefinitions, "Type Definitions")
    test_framework.RunTest(testTypeConversions, "Type Conversions")
    test_framework.RunTest(testTypeAssertions, "Type Assertions")
    test_framework.RunTest(testNestedTypes, "Nested Types")
    test_framework.RunTest(testRecursiveTypes, "Recursive Types")
    
    // Print test results
    test_framework.PrintResults()
}

// Test basic types
數 testBasicTypes() {
    // Boolean type
    let b bool = true
    test_framework.Assert(b, "Boolean true value")
    b = false
    test_framework.Assert(!b, "Boolean false value")
    
    // Integer types
    let i int = 42
    test_framework.AssertEqual(i, 42, "Integer type")
    
    let i8 int8 = 127
    test_framework.AssertEqual(i8, 127, "8-bit integer type")
    
    let i16 int16 = 32767
    test_framework.AssertEqual(i16, 32767, "16-bit integer type")
    
    let i32 int32 = 2147483647
    test_framework.AssertEqual(i32, 2147483647, "32-bit integer type")
    
    let i64 int64 = 9223372036854775807
    test_framework.AssertEqual(i64, 9223372036854775807, "64-bit integer type")
    
    // Unsigned integer types
    let ui uint = 42
    test_framework.AssertEqual(ui, uint(42), "Unsigned integer type")
    
    let ui8 uint8 = 255
    test_framework.AssertEqual(ui8, uint8(255), "8-bit unsigned integer type")
    
    let ui16 uint16 = 65535
    test_framework.AssertEqual(ui16, uint16(65535), "16-bit unsigned integer type")
    
    let ui32 uint32 = 4294967295
    test_framework.AssertEqual(ui32, uint32(4294967295), "32-bit unsigned integer type")
    
    let ui64 uint64 = 18446744073709551615
    test_framework.AssertEqual(ui64, uint64(18446744073709551615), "64-bit unsigned integer type")
    
    // Byte type (alias for uint8)
    let byteVal byte = 255
    test_framework.AssertEqual(byteVal, byte(255), "Byte type")
    
    // Rune type (alias for int32)
    let r rune = 'A'
    test_framework.AssertEqual(r, rune(65), "Rune type")
    
    // Floating-point types
    let f32 float32 = 3.14
    test_framework.Assert(f32 > 3.13 && f32 < 3.15, "32-bit float type")
    
    let f64 float64 = 3.14159265359
    test_framework.Assert(f64 > 3.141592 && f64 < 3.141593, "64-bit float type")
    
    // Complex types
    let c64 complex64 = 1 + 2i
    test_framework.Assert(real(c64) == 1 && imag(c64) == 2, "64-bit complex type")
    
    let c128 complex128 = 1.5 + 2.5i
    test_framework.Assert(real(c128) == 1.5 && imag(c128) == 2.5, "128-bit complex type")
    
    // String type
    let s string = "Hello, World!"
    test_framework.AssertEqual(s, "Hello, World!", "String type")
    
    // Default values
    let defaultBool bool
    test_framework.Assert(!defaultBool, "Default boolean value is false")
    
    let defaultInt int
    test_framework.AssertEqual(defaultInt, 0, "Default integer value is 0")
    
    let defaultFloat float64
    test_framework.AssertEqual(defaultFloat, 0.0, "Default float value is 0.0")
    
    let defaultString string
    test_framework.AssertEqual(defaultString, "", "Default string value is empty string")
}

// Test array types
數 testArrayTypes() {
    // Array declaration and initialization
    let arr1 [5]int = [5]int{1, 2, 3, 4, 5}
    test_framework.AssertEqual(len(arr1), 5, "Array length")
    test_framework.AssertEqual(arr1[0], 1, "First element of array")
    test_framework.AssertEqual(arr1[4], 5, "Last element of array")
    
    // Short array declaration
    let arr2 = [3]string{"a", "b", "c"}
    test_framework.AssertEqual(len(arr2), 3, "Array length")
    test_framework.AssertEqual(arr2[1], "b", "Second element of array")
    
    // Array with elided length
    let arr3 = [...]int{1, 2, 3, 4, 5}
    test_framework.AssertEqual(len(arr3), 5, "Array with elided length")
    
    // Array with sparse initialization
    let arr4 = [5]int{0: 1, 2: 3, 4: 5}
    test_framework.AssertEqual(arr4[0], 1, "First element of sparse array")
    test_framework.AssertEqual(arr4[1], 0, "Second element of sparse array")
    test_framework.AssertEqual(arr4[2], 3, "Third element of sparse array")
    test_framework.AssertEqual(arr4[3], 0, "Fourth element of sparse array")
    test_framework.AssertEqual(arr4[4], 5, "Fifth element of sparse array")
    
    // Multidimensional array
    let arr5 [2][3]int = [2][3]int{{1, 2, 3}, {4, 5, 6}}
    test_framework.AssertEqual(arr5[0][1], 2, "Element of multidimensional array")
    test_framework.AssertEqual(arr5[1][2], 6, "Element of multidimensional array")
    
    // Array assignment
    let arr6 [3]int = [3]int{1, 2, 3}
    arr6[1] = 20
    test_framework.AssertEqual(arr6[1], 20, "Array element assignment")
    
    // Array comparison
    let arr7 = [3]int{1, 2, 3}
    let arr8 = [3]int{1, 2, 3}
    let arr9 = [3]int{3, 2, 1}
    test_framework.Assert(arr7 == arr8, "Equal arrays comparison")
    test_framework.Assert(arr7 != arr9, "Unequal arrays comparison")
    
    // Array copying
    let arr10 = arr7
    test_framework.AssertEqual(arr10, arr7, "Array copy")
    arr10[0] = 10
    test_framework.Assert(arr10 != arr7, "Array copy is independent of original")
}

// Test slice types
數 testSliceTypes() {
    // Slice declaration and initialization
    let slice1 []int = []int{1, 2, 3, 4, 5}
    test_framework.AssertEqual(len(slice1), 5, "Slice length")
    test_framework.AssertEqual(cap(slice1), 5, "Slice capacity")
    test_framework.AssertEqual(slice1[0], 1, "First element of slice")
    test_framework.AssertEqual(slice1[4], 5, "Last element of slice")
    
    // Slice from array
    let arr = [5]int{1, 2, 3, 4, 5}
    let slice2 = arr[1:4]
    test_framework.AssertEqual(len(slice2), 3, "Slice from array length")
    test_framework.AssertEqual(cap(slice2), 4, "Slice from array capacity")
    test_framework.AssertEqual(slice2[0], 2, "First element of slice from array")
    test_framework.AssertEqual(slice2[2], 4, "Last element of slice from array")
    
    // Slice with make
    let slice3 = make([]int, 3, 5)
    test_framework.AssertEqual(len(slice3), 3, "Slice with make length")
    test_framework.AssertEqual(cap(slice3), 5, "Slice with make capacity")
    
    // Slice with default indices
    let slice4 = arr[:]
    test_framework.AssertEqual(len(slice4), 5, "Slice with default indices length")
    test_framework.AssertEqual(slice4[0], 1, "First element of slice with default indices")
    
    // Slice with default start index
    let slice5 = arr[:3]
    test_framework.AssertEqual(len(slice5), 3, "Slice with default start index length")
    test_framework.AssertEqual(slice5[0], 1, "First element of slice with default start index")
    
    // Slice with default end index
    let slice6 = arr[2:]
    test_framework.AssertEqual(len(slice6), 3, "Slice with default end index length")
    test_framework.AssertEqual(slice6[0], 3, "First element of slice with default end index")
    
    // Slice append
    let slice7 = []int{1, 2, 3}
    slice7 = append(slice7, 4, 5)
    test_framework.AssertEqual(len(slice7), 5, "Slice append length")
    test_framework.AssertEqual(slice7[3], 4, "Append first element")
    test_framework.AssertEqual(slice7[4], 5, "Append second element")
    
    // Slice append multiple slices
    let slice8 = []int{1, 2}
    let slice9 = []int{3, 4}
    let slice10 = append(slice8, slice9...)
    test_framework.AssertEqual(len(slice10), 4, "Slice append multiple slices length")
    test_framework.AssertEqual(slice10[2], 3, "Append first element from second slice")
    
    // Slice copy
    let slice11 = make([]int, 3)
    let n = copy(slice11, []int{7, 8, 9, 10})
    test_framework.AssertEqual(n, 3, "Number of elements copied")
    test_framework.AssertEqual(slice11[0], 7, "First copied element")
    test_framework.AssertEqual(slice11[2], 9, "Last copied element")
    
    // Slice is a reference
    let slice12 = []int{1, 2, 3}
    let slice13 = slice12
    slice13[0] = 10
    test_framework.AssertEqual(slice12[0], 10, "Slice is a reference type")
    
    // Nil slice
    let slice14 []int
    test_framework.Assert(slice14 == nil, "Nil slice")
    test_framework.AssertEqual(len(slice14), 0, "Nil slice length")
}

// Test map types
數 testMapTypes() {
    // Map declaration and initialization
    let map1 map[string]int = map[string]int{
        "one":   1,
        "two":   2,
        "three": 3,
    }
    test_framework.AssertEqual(len(map1), 3, "Map length")
    test_framework.AssertEqual(map1["one"], 1, "Map key-value pair")
    test_framework.AssertEqual(map1["three"], 3, "Map key-value pair")
    
    // Short map declaration
    let map2 = map[string]bool{"true": true, "false": false}
    test_framework.AssertEqual(len(map2), 2, "Map length")
    test_framework.Assert(map2["true"], "Map boolean value")
    test_framework.Assert(!map2["false"], "Map boolean value")
    
    // Map with make
    let map3 = make(map[int]string)
    test_framework.AssertEqual(len(map3), 0, "Map with make is empty")
    
    // Map with make and initial capacity
    let map4 = make(map[int]string, 10)
    test_framework.AssertEqual(len(map4), 0, "Map with make and capacity is empty")
    
    // Map assignment
    map3[1] = "one"
    map3[2] = "two"
    test_framework.AssertEqual(len(map3), 2, "Map assignment increases length")
    test_framework.AssertEqual(map3[1], "one", "Map key-value assignment")
    
    // Map lookup
    let val, ok = map1["two"]
    test_framework.Assert(ok, "Key exists in map")
    test_framework.AssertEqual(val, 2, "Map lookup value")
    
    // Map lookup for nonexistent key
    val, ok = map1["four"]
    test_framework.Assert(!ok, "Key does not exist in map")
    test_framework.AssertEqual(val, 0, "Map lookup default value for nonexistent key")
    
    // Map deletion
    delete(map1, "two")
    test_framework.AssertEqual(len(map1), 2, "Map length after deletion")
    _, ok = map1["two"]
    test_framework.Assert(!ok, "Key no longer exists in map after deletion")
    
    // Map iteration
    let map5 = map[string]int{"a": 1, "b": 2, "c": 3}
    let sum = 0
    for _, value := range map5 {
        sum += value
    }
    test_framework.AssertEqual(sum, 6, "Map values sum")
    
    // Map keys iteration
    let keys = []string{}
    for key := range map5 {
        keys = append(keys, key)
    }
    test_framework.AssertEqual(len(keys), 3, "Number of keys in map")
    
    // Maps are reference types
    let map6 = map5
    map6["a"] = 10
    test_framework.AssertEqual(map5["a"], 10, "Maps are reference types")
    
    // Nil map
    var map7 map[string]int
    test_framework.Assert(map7 == nil, "Nil map")
    test_framework.AssertEqual(len(map7), 0, "Nil map length")
    // This would cause a runtime error:
    // map7["x"] = 10
}

// Test struct types
數 testStructTypes() {
    // Struct declaration and initialization
    let person1 = Person{
        Name: "John",
        Age:  30,
    }
    test_framework.AssertEqual(person1.Name, "John", "Struct field access")
    test_framework.AssertEqual(person1.Age, 30, "Struct field access")
    
    // Struct with anonymous fields
    let person2 = Person{
        "Jane",
        25,
    }
    test_framework.AssertEqual(person2.Name, "Jane", "Struct anonymous field")
    test_framework.AssertEqual(person2.Age, 25, "Struct anonymous field")
    
    // Struct with nested struct
    let employee1 = Employee{
        Person: Person{
            Name: "Bob",
            Age:  40,
        },
        Company: "Acme Inc",
        Salary:  50000,
    }
    test_framework.AssertEqual(employee1.Person.Name, "Bob", "Nested struct field")
    test_framework.AssertEqual(employee1.Company, "Acme Inc", "Struct field")
    
    // Struct with embedded struct
    let manager1 = Manager{
        Person: Person{
            Name: "Alice",
            Age:  35,
        },
        Department: "Engineering",
        Team:       []string{"Bob", "Charlie"},
    }
    test_framework.AssertEqual(manager1.Name, "Alice", "Embedded struct field promotion")
    test_framework.AssertEqual(manager1.Person.Age, 35, "Embedded struct field access")
    test_framework.AssertEqual(manager1.Department, "Engineering", "Struct field")
    
    // Struct with pointer to struct
    let department = &Department{
        Name:     "HR",
        Location: "Building A",
    }
    test_framework.AssertEqual(department.Name, "HR", "Pointer to struct automatic dereference")
    
    // Anonymous struct
    let point = struct {
        X int
        Y int
    }{
        X: 10,
        Y: 20,
    }
    test_framework.AssertEqual(point.X, 10, "Anonymous struct field")
    test_framework.AssertEqual(point.Y, 20, "Anonymous struct field")
    
    // Struct with tags
    let tagged = Tagged{
        Field: "value",
    }
    test_framework.AssertEqual(tagged.Field, "value", "Struct with tags field")
    
    // Struct equality
    let person3 = Person{Name: "John", Age: 30}
    let person4 = Person{Name: "John", Age: 30}
    let person5 = Person{Name: "Jane", Age: 25}
    test_framework.Assert(person3 == person4, "Equal structs")
    test_framework.Assert(person3 != person5, "Unequal structs")
    
    // Zero value struct
    let zero Person
    test_framework.AssertEqual(zero.Name, "", "Zero value struct field")
    test_framework.AssertEqual(zero.Age, 0, "Zero value struct field")
}

// Test interface types
數 testInterfaceTypes() {
    // Interface implementation
    let s Shape = &Circle{Radius: 5}
    test_framework.AssertEqual(s.Area(), 78.53981633974483, "Interface method call")
    
    // Interface with multiple methods
    let t Talker = Dog{Name: "Rex"}
    test_framework.AssertEqual(t.Speak(), "Woof!", "Interface method call")
    test_framework.AssertEqual(t.GetName(), "Rex", "Interface method call")
    
    // Empty interface
    let e interface{} = 42
    test_framework.AssertEqual(e, 42, "Empty interface value")
    
    e = "hello"
    test_framework.AssertEqual(e, "hello", "Empty interface value reassignment")
    
    // Interface with embedded interface
    let p Printable = Cat{Name: "Fluffy"}
    test_framework.AssertEqual(p.Speak(), "Meow!", "Embedded interface method call")
    test_framework.AssertEqual(p.String(), "Cat: Fluffy", "Interface method call")
    
    // Interface equality
    let t1 Talker = Dog{Name: "Rex"}
    let t2 Talker = Dog{Name: "Rex"}
    let t3 Talker = Dog{Name: "Buddy"}
    test_framework.Assert(t1 == t2, "Equal interface values")
    test_framework.Assert(t1 != t3, "Unequal interface values")
    
    // Nil interface
    let var1 Shape
    test_framework.Assert(var1 == nil, "Nil interface value")
    
    // Interface with nil value but non-nil type
    var c *Circle
    let var2 Shape = c
    test_framework.Assert(var2 != nil, "Interface with nil value but non-nil type")
}

// Test function types
數 testFunctionTypes() {
    // Function declaration
    let fn1 = func(a, b int) int {
        return a + b
    }
    test_framework.AssertEqual(fn1(2, 3), 5, "Function call")
    
    // Function type declaration
    type MathFunc func(int, int) int
    let add MathFunc = func(a, b int) int {
        return a + b
    }
    test_framework.AssertEqual(add(2, 3), 5, "Function with type call")
    
    // Function as parameter
    let result = applyFunc(2, 3, add)
    test_framework.AssertEqual(result, 5, "Function as parameter")
    
    // Function returning function
    let multiplier = getMultiplier(10)
    test_framework.AssertEqual(multiplier(5), 50, "Function returned from function")
    
    // Function with variadic parameters
    let sum = sumAll(1, 2, 3, 4, 5)
    test_framework.AssertEqual(sum, 15, "Function with variadic parameters")
    
    // Function with named return values
    let a, b = divideAndRemainder(10, 3)
    test_framework.AssertEqual(a, 3, "Function with named return values - quotient")
    test_framework.AssertEqual(b, 1, "Function with named return values - remainder")
    
    // Anonymous function
    test_framework.AssertEqual(func(x int) int { return x * x }(4), 16, "Anonymous function")
    
    // Closure
    let counter = createCounter()
    test_framework.AssertEqual(counter(), 1, "Closure first call")
    test_framework.AssertEqual(counter(), 2, "Closure second call")
    
    // Function as field in struct
    let calculator = Calculator{
        Add: func(a, b int) int {
            return a + b
        },
    }
    test_framework.AssertEqual(calculator.Add(2, 3), 5, "Function as struct field")
    
    // Function equality (functions are not comparable)
    // This would be a compile-time error:
    // let fn2 = func(a, b int) int { return a + b }
    // test_framework.Assert(fn1 == fn2, "Equal functions")
}

// Test channel types
數 testChannelTypes() {
    // Channel declaration
    let ch1 = make(chan int)
    
    // Sending and receiving (need goroutines for unbuffered channels)
    go func() {
        ch1 <- 42
    }()
    let val = <-ch1
    test_framework.AssertEqual(val, 42, "Channel send and receive")
    
    // Buffered channel
    let ch2 = make(chan string, 2)
    ch2 <- "hello"
    ch2 <- "world"
    test_framework.AssertEqual(<-ch2, "hello", "Buffered channel first value")
    test_framework.AssertEqual(<-ch2, "world", "Buffered channel second value")
    
    // Channel direction
    let sendCh = createSender()
    let recvCh = createReceiver(5)
    
    // Send-only channel
    go func() {
        sendCh <- 10
    }()
    
    // Receive-only channel
    let val2 = <-recvCh
    test_framework.AssertEqual(val2, 5, "Receive-only channel")
    
    // Close channel
    let ch3 = make(chan int, 2)
    ch3 <- 1
    ch3 <- 2
    close(ch3)
    
    let v1 = <-ch3
    let v2 = <-ch3
    let v3, ok := <-ch3
    test_framework.AssertEqual(v1, 1, "Value from closed channel")
    test_framework.AssertEqual(v2, 2, "Value from closed channel")
    test_framework.AssertEqual(v3, 0, "Zero value from closed channel")
    test_framework.Assert(!ok, "Channel is closed")
    
    // Range over channel
    let ch4 = make(chan int, 3)
    ch4 <- 1
    ch4 <- 2
    ch4 <- 3
    close(ch4)
    
    let sum = 0
    for n := range ch4 {
        sum += n
    }
    test_framework.AssertEqual(sum, 6, "Range over channel")
    
    // Select statement
    let ch5 = make(chan int)
    let ch6 = make(chan int)
    let done = make(chan bool)
    
    go func() {
        ch5 <- 5
        done <- true
    }()
    
    go func() {
        ch6 <- 6
    }()
    
    let selected := 0
    select {
    case val := <-ch5:
        selected = val
    case val := <-ch6:
        selected = val
    }
    
    <-done
    test_framework.Assert(selected == 5 || selected == 6, "Select statement")
}

// Test pointer types
數 testPointerTypes() {
    // Pointer declaration
    let x = 42
    let p = &x
    test_framework.AssertEqual(*p, 42, "Pointer dereference")
    
    // Pointer modification
    *p = 24
    test_framework.AssertEqual(x, 24, "Original value modified via pointer")
    
    // Nil pointer
    let nilPtr *int
    test_framework.Assert(nilPtr == nil, "Nil pointer")
    
    // Pointer to struct
    let person = &Person{Name: "John", Age: 30}
    test_framework.AssertEqual(person.Name, "John", "Pointer to struct field access")
    
    // Automatic dereference
    person.Age = 31
    test_framework.AssertEqual((*person).Age, 31, "Explicit dereference")
    
    // Pointer arithmetic is not supported in Go/Saika
    // This would be a compile-time error:
    // p++
    
    // Pointer to pointer
    let pp = &p
    test_framework.AssertEqual(**pp, 24, "Pointer to pointer")
    
    // Function returning pointer
    let newPerson = createPerson("Jane")
    test_framework.AssertEqual(newPerson.Name, "Jane", "Function returning pointer")
    
    // Taking address of composite literals
    let nums = &[]int{1, 2, 3}
    test_framework.AssertEqual((*nums)[0], 1, "Pointer to slice")
    
    // Pointer comparison
    let y = 24
    let p2 = &y
    let p3 = &x
    test_framework.Assert(p != p2, "Different pointers to same value")
    test_framework.Assert(p == p3, "Same pointer")
}

// Test type aliases
數 testTypeAliases() {
    // Type alias declaration
    type Celsius = float64
    let temp Celsius = 36.5
    test_framework.AssertEqual(temp, 36.5, "Type alias value")
    
    // Type alias equality with original type
    let regularTemp float64 = 36.5
    test_framework.Assert(temp == regularTemp, "Type alias equals original type")
    
    // Type alias in function signature
    type IntFunc = func(int) int
    let square IntFunc = func(x int) int {
        return x * x
    }
    test_framework.AssertEqual(square(4), 16, "Type alias function")
    
    // Built-in type aliases
    let b byte = 65  // byte is an alias for uint8
    let r rune = 'A' // rune is an alias for int32
    test_framework.AssertEqual(byte(b), uint8(65), "byte alias")
    test_framework.AssertEqual(rune(r), int32(65), "rune alias")
    
    // Type alias with methods
    type MyFloat = float64
    let f MyFloat = 3.14
    test_framework.AssertEqual(float64(f), 3.14, "MyFloat equals float64")
}

// Test type definitions
數 testTypeDefinitions() {
    // Type definition
    let temp Temperature(36.5)
    test_framework.AssertEqual(float64(temp), 36.5, "Type definition conversion to underlying type")
    
    // Type definition methods
    test_framework.AssertEqual(temp.String(), "36.5°C", "Method on type definition")
    
    // Type definition is not equal to underlying type
    // Type definitions create new types, unlike type aliases
    let regularTemp float64 = 36.5
    // This would be a compile-time error (types not equal):
    // test_framework.Assert(temp == regularTemp, "Type definition equals underlying type")
    
    // Explicit conversion required
    test_framework.AssertEqual(Temperature(regularTemp), temp, "Explicit conversion to type definition")
    test_framework.AssertEqual(float64(temp), regularTemp, "Explicit conversion to underlying type")
    
    // Type definitions in collections
    let temps = []Temperature{Temperature(0), Temperature(100)}
    test_framework.AssertEqual(float64(temps[1]), 100.0, "Type definition in slice")
    
    // Type definition with struct
    let user = User{ID: 1, Name: "John"}
    test_framework.AssertEqual(user.ID, UserID(1), "Type definition in struct")
    
    // Comparable type definitions
    let id1 = UserID(1)
    let id2 = UserID(1)
    let id3 = UserID(2)
    test_framework.Assert(id1 == id2, "Equal type definition values")
    test_framework.Assert(id1 != id3, "Unequal type definition values")
}

// Test type conversions
數 testTypeConversions() {
    // Basic type conversions
    let i = 42
    let f = float64(i)
    test_framework.AssertEqual(f, 42.0, "Integer to float conversion")
    
    // Truncation in conversion
    let f2 = 42.9
    let i2 = int(f2)
    test_framework.AssertEqual(i2, 42, "Float to integer truncates")
    
    // String conversion
    let r = 'A'
    let s = string(r)
    test_framework.AssertEqual(s, "A", "Rune to string conversion")
    
    // Slice conversions
    let str = "hello"
    let bytes = []byte(str)
    test_framework.AssertEqual(len(bytes), 5, "String to byte slice conversion")
    
    let runes = []rune(str)
    test_framework.AssertEqual(len(runes), 5, "String to rune slice conversion")
    
    let backToStr = string(bytes)
    test_framework.AssertEqual(backToStr, "hello", "Byte slice to string conversion")
    
    // Custom type conversions
    let temp = Temperature(98.6)
    let kelvin = Kelvin(temp)
    test_framework.Assert(float64(kelvin) > 300, "Custom type conversion")
    
    // Struct to struct conversion
    // Go/Saika doesn't support direct conversion between structs
    // This would be a compile-time error:
    // let p = Person{Name: "John", Age: 30}
    // let u = User(p)
    
    // But we can create a new struct with fields from another
    let p = Person{Name: "John", Age: 30}
    let u = User{ID: UserID(1), Name: p.Name}
    test_framework.AssertEqual(u.Name, "John", "Manual struct field conversion")
}

// Test type assertions
數 testTypeAssertions() {
    // Empty interface with value
    let val interface{} = 42
    
    // Type assertion
    let i, ok = val.(int)
    test_framework.Assert(ok, "Type assertion success")
    test_framework.AssertEqual(i, 42, "Type assertion value")
    
    // Failed type assertion
    let s, ok2 = val.(string)
    test_framework.Assert(!ok2, "Type assertion failure")
    test_framework.AssertEqual(s, "", "Type assertion default value")
    
    // Type assertion without check
    // This would panic if the assertion fails:
    // let directAssertion = val.(string)
    
    // Type assertion with interface type
    let circle = &Circle{Radius: 5}
    let shape Shape = circle
    let circleAgain, ok3 = shape.(*Circle)
    test_framework.Assert(ok3, "Interface type assertion success")
    test_framework.AssertEqual(circleAgain.Radius, 5, "Interface type assertion value")
    
    // Type switch
    let typeStr = ""
    switch x := val.(type) {
    case int:
        typeStr = fmt.Sprintf("int: %d", x)
    case string:
        typeStr = fmt.Sprintf("string: %s", x)
    case bool:
        typeStr = fmt.Sprintf("bool: %t", x)
    default:
        typeStr = "unknown type"
    }
    test_framework.AssertEqual(typeStr, "int: 42", "Type switch")
    
    // Type assertions in function calls
    test_framework.AssertEqual(processValue(val), "Processed: 42", "Type assertion in function")
    test_framework.AssertEqual(processValue("hello"), "Processed: hello", "Type assertion in function")
}

// Test nested types
數 testNestedTypes() {
    // Struct with nested struct
    let employee = Employee{
        Person: Person{
            Name: "John",
            Age:  30,
        },
        Company: "Acme Inc",
        Salary:  50000,
    }
    test_framework.AssertEqual(employee.Person.Name, "John", "Nested struct field access")
    
    // Struct with embedded struct
    let manager = Manager{
        Person: Person{
            Name: "Alice",
            Age:  35,
        },
        Department: "Engineering",
        Team:       []string{"Bob", "Charlie"},
    }
    test_framework.AssertEqual(manager.Name, "Alice", "Embedded struct field promotion")
    
    // Struct with nested slices
    let department = Department{
        Name:     "Engineering",
        Location: "Building A",
        Teams: []Team{
            {Name: "Frontend", Size: 5},
            {Name: "Backend", Size: 8},
        },
    }
    test_framework.AssertEqual(department.Teams[1].Name, "Backend", "Nested slice of structs")
    
    // Map with struct values
    let employeeMap = map[string]Person{
        "john": {Name: "John", Age: 30},
        "jane": {Name: "Jane", Age: 25},
    }
    test_framework.AssertEqual(employeeMap["jane"].Age, 25, "Map with struct values")
    
    // Slice of maps
    let projectResources = []map[string]int{
        {"Frontend": 3, "Backend": 5},
        {"Frontend": 2, "Backend": 4},
    }
    test_framework.AssertEqual(projectResources[0]["Backend"], 5, "Slice of maps")
    
    // Function returning nested types
    let org = getOrganization()
    test_framework.AssertEqual(org.Name, "Acme Inc", "Function returning nested struct")
    test_framework.AssertEqual(org.Departments[0].Teams[0].Name, "Frontend", "Deeply nested field")
}

// Test recursive types
數 testRecursiveTypes() {
    // Recursive struct (linked list)
    let list = &ListNode{
        Value: 1,
        Next: &ListNode{
            Value: 2,
            Next: &ListNode{
                Value: 3,
                Next: nil,
            },
        },
    }
    test_framework.AssertEqual(list.Value, 1, "Recursive struct first node")
    test_framework.AssertEqual(list.Next.Value, 2, "Recursive struct second node")
    test_framework.AssertEqual(list.Next.Next.Value, 3, "Recursive struct third node")
    
    // Recursive struct (tree)
    let tree = &TreeNode{
        Value: 1,
        Left: &TreeNode{
            Value: 2,
            Left:  nil,
            Right: nil,
        },
        Right: &TreeNode{
            Value: 3,
            Left:  nil,
            Right: nil,
        },
    }
    test_framework.AssertEqual(tree.Value, 1, "Recursive tree root node")
    test_framework.AssertEqual(tree.Left.Value, 2, "Recursive tree left node")
    test_framework.AssertEqual(tree.Right.Value, 3, "Recursive tree right node")
    
    // Recursive function to traverse linked list
    let sum = sumList(list)
    test_framework.AssertEqual(sum, 6, "Recursive function on recursive type")
    
    // Mutual recursion through interfaces
    let file = &File{Name: "document.txt"}
    let dir = &Directory{
        Name: "docs",
        Contents: []FileSystem{
            file,
        },
    }
    test_framework.AssertEqual(dir.GetName(), "docs", "Recursive interface implementation")
    test_framework.AssertEqual(dir.GetSize(), 1, "Recursive interface method call")
}

// ==================
// Helper types and functions
// ==================

// Person struct
struct Person {
    Name string
    Age  int
}

// Employee struct with nested Person
struct Employee {
    Person  Person
    Company string
    Salary  int
}

// Manager struct with embedded Person
struct Manager {
    Person
    Department string
    Team       []string
}

// Department struct
struct Department {
    Name     string
    Location string
    Teams    []Team
}

// Team struct
struct Team {
    Name string
    Size int
}

// Organization struct
struct Organization {
    Name        string
    Departments []Department
}

// Tagged struct
struct Tagged {
    Field string `json:"field_name" xml:"field"`
}

// Interface for shapes
interface Shape {
    Area() float64
}

// Circle that implements Shape
struct Circle {
    Radius float64
}

數 (c *Circle) Area() float64 {
    return 3.14159265358979 * c.Radius * c.Radius
}

// Interface with multiple methods
interface Talker {
    Speak() string
    GetName() string
}

// Dog that implements Talker
struct Dog {
    Name string
}

數 (d Dog) Speak() string {
    return "Woof!"
}

數 (d Dog) GetName() string {
    return d.Name
}

// Interface that embeds another interface
interface Printable extends Talker {
    String() string
}

// Cat that implements Printable
struct Cat {
    Name string
}

數 (c Cat) Speak() string {
    return "Meow!"
}

數 (c Cat) GetName() string {
    return c.Name
}

數 (c Cat) String() string {
    return fmt.Sprintf("Cat: %s", c.Name)
}

// Calculator struct with function field
struct Calculator {
    Add func(a, b int) int
}

// Type definition for temperature
type Temperature float64

// Method on type definition
數 (t Temperature) String() string {
    return fmt.Sprintf("%.1f°C", t)
}

// Type definition for kelvin temperature
type Kelvin float64

// Converting between temperature types
數 (t Temperature) ToKelvin() Kelvin {
    return Kelvin(t + 273.15)
}

// Type definition for user ID
type UserID int

// User struct using type definition
struct User {
    ID   UserID
    Name string
}

// Recursive linked list node
struct ListNode {
    Value int
    Next  *ListNode
}

// Recursive tree node
struct TreeNode {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

// Interface for recursive types
interface FileSystem {
    GetName() string
    GetSize() int
}

// File that implements FileSystem
struct File {
    Name string
}

數 (f *File) GetName() string {
    return f.Name
}

數 (f *File) GetSize() int {
    return 1
}

// Directory that implements FileSystem and contains FileSystem
struct Directory {
    Name     string
    Contents []FileSystem
}

數 (d *Directory) GetName() string {
    return d.Name
}

數 (d *Directory) GetSize() int {
    size := 0
    for _, item := range d.Contents {
        size += item.GetSize()
    }
    return size
}

// Helper function for function types test
數 applyFunc(a, b int, fn func(int, int) int) int {
    return fn(a, b)
}

// Helper function that returns a function
數 getMultiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

// Helper function with variadic parameters
數 sumAll(nums ...int) int {
    result := 0
    for _, num := range nums {
        result += num
    }
    return result
}

// Helper function with named return values
數 divideAndRemainder(a, b int) (quotient, remainder int) {
    quotient = a / b
    remainder = a % b
    return
}

// Helper function that creates a closure
數 createCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// Helper functions for channel tests
數 createSender() chan<- int {
    ch := make(chan int)
    return ch
}

數 createReceiver(value int) <-chan int {
    ch := make(chan int, 1)
    ch <- value
    return ch
}

// Helper function that returns a pointer
數 createPerson(name string) *Person {
    return &Person{
        Name: name,
        Age:  0,
    }
}

// Helper function for type assertions
數 processValue(val interface{}) string {
    switch v := val.(type) {
    case int:
        return fmt.Sprintf("Processed: %d", v)
    case string:
        return fmt.Sprintf("Processed: %s", v)
    default:
        return "Processed: unknown type"
    }
}

// Helper function for nested types
數 getOrganization() Organization {
    return Organization{
        Name: "Acme Inc",
        Departments: []Department{
            {
                Name:     "Engineering",
                Location: "Building A",
                Teams: []Team{
                    {Name: "Frontend", Size: 5},
                    {Name: "Backend", Size: 8},
                },
            },
        },
    }
}

// Helper function for recursive types
數 sumList(node *ListNode) int {
    if node == nil {
        return 0
    }
    return node.Value + sumList(node.Next)
}