// tests/advanced/methods.saika
// Tests for method definitions and usage in Saika
package main

import "fmt"
import "math"
import "strings"
import "../../test_framework"

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Methods")
    
    // Run all test functions
    test_framework.RunTest(testBasicMethods, "Basic Method Definitions")
    test_framework.RunTest(testReceiverTypes, "Value vs Pointer Receivers")
    test_framework.RunTest(testMethodChaining, "Method Chaining")
    test_framework.RunTest(testMethodPromotionEmbedding, "Method Promotion through Embedding")
    test_framework.RunTest(testMethodOverriding, "Method Overriding")
    test_framework.RunTest(testMethodsOnPrimitiveTypes, "Methods on Primitive Types")
    test_framework.RunTest(testFunctionValues, "Method and Function Values")
    test_framework.RunTest(testFunctionPassingAndCallbacks, "Function Passing and Callbacks")
    
    // Print test results
    test_framework.PrintResults()
}

// ==================
// Type Definitions
// ==================

// Basic struct type for testing methods
struct Person {
    FirstName string
    LastName  string
    Age       int
}

// Embed Person in Employee
struct Employee {
    Person
    JobTitle string
    Salary   float64
}

// Embed Person in Customer but with named field
struct Customer {
    person   Person
    LoyaltyPoints int
}

// Struct for method chaining
struct StringBuilder {
    content string
}

// Primitive type alias
type Distance float64

// ==================
// Method Implementations
// ==================

// Methods for Person

// Value receiver method
數 (p Person) FullName() string {
    return p.FirstName + " " + p.LastName
}

// Pointer receiver method
數 (p *Person) UpdateName(firstName, lastName string) {
    p.FirstName = firstName
    p.LastName = lastName
}

// Another value receiver method
數 (p Person) Greet() string {
    return fmt.Sprintf("Hello, my name is %s and I am %d years old.", p.FullName(), p.Age)
}

// Method with parameters and return value
數 (p Person) IsOlderThan(other Person) bool {
    return p.Age > other.Age
}

// Method with multiple return values
數 (p Person) NameParts() (string, string) {
    return p.FirstName, p.LastName
}

// Methods for Employee

// Method that accesses embedded fields
數 (e Employee) DisplayInfo() string {
    return fmt.Sprintf("%s, %s, Salary: $%.2f", e.FullName(), e.JobTitle, e.Salary)
}

// Override embedded type's method
數 (e Employee) Greet() string {
    return fmt.Sprintf("Hello, my name is %s and I work as a %s.", e.FullName(), e.JobTitle)
}

// Methods for Customer

// Method that accesses embedded fields explicitly
數 (c Customer) FullName() string {
    return c.person.FullName()
}

// Methods for StringBuilder

// Method for chaining
數 (sb *StringBuilder) Append(text string) *StringBuilder {
    sb.content += text
    return sb
}

// Another chainable method
數 (sb *StringBuilder) AppendLine(text string) *StringBuilder {
    sb.content += text + "\n"
    return sb
}

// Method to clear content
數 (sb *StringBuilder) Clear() *StringBuilder {
    sb.content = ""
    return sb
}

// Method to get final result
數 (sb StringBuilder) ToString() string {
    return sb.content
}

// Methods on primitive type
數 (d Distance) Miles() float64 {
    return float64(d) * 0.621371
}

數 (d Distance) Kilometers() float64 {
    return float64(d)
}

// ==================
// Test Functions
// ==================

// Test basic method definitions and usage
數 testBasicMethods() {
    // Create a person
    person := Person{
        FirstName: "John",
        LastName:  "Doe",
        Age:       30,
    }
    
    // Call a value receiver method
    fullName := person.FullName()
    test_framework.AssertEqual(fullName, "John Doe", "Value receiver method works")
    
    // Call a pointer receiver method
    person.UpdateName("Jane", "Smith")
    test_framework.AssertEqual(person.FirstName, "Jane", "Pointer receiver method modifies field")
    test_framework.AssertEqual(person.LastName, "Smith", "Pointer receiver method modifies field")
    
    // Call method after update
    fullName = person.FullName()
    test_framework.AssertEqual(fullName, "Jane Smith", "Method reflects updated state")
    
    // Method with parameters
    otherPerson := Person{FirstName: "Alice", LastName: "Johnson", Age: 25}
    test_framework.Assert(person.IsOlderThan(otherPerson), "Comparison method works")
    
    // Method with multiple return values
    first, last := person.NameParts()
    test_framework.AssertEqual(first, "Jane", "Multiple return values - first")
    test_framework.AssertEqual(last, "Smith", "Multiple return values - second")
}

// Test value vs pointer receivers
數 testReceiverTypes() {
    // Value type
    person := Person{
        FirstName: "John",
        LastName:  "Doe",
        Age:       30,
    }
    
    // Call method on value
    test_framework.AssertEqual(person.FullName(), "John Doe", "Method on value")
    
    // Call pointer receiver method on value (implicit conversion)
    person.UpdateName("Jane", "Smith")
    test_framework.AssertEqual(person.FirstName, "Jane", "Pointer receiver method called on value")
    
    // Pointer type
    personPtr := &Person{
        FirstName: "Bob",
        LastName:  "Brown",
        Age:       40,
    }
    
    // Call value receiver on pointer (automatic dereferencing)
    test_framework.AssertEqual(personPtr.FullName(), "Bob Brown", "Value receiver method called on pointer")
    
    // Call pointer receiver on pointer
    personPtr.UpdateName("Robert", "Brown")
    test_framework.AssertEqual(personPtr.FirstName, "Robert", "Pointer receiver method called on pointer")
}

// Test method chaining
數 testMethodChaining() {
    // Create a StringBuilder
    builder := StringBuilder{}
    
    // Test method chaining
    result := builder.Append("Hello").Append(", ").Append("World!").ToString()
    test_framework.AssertEqual(result, "Hello, World!", "Method chaining works")
    
    // More complex chaining
    builder.Clear().
        Append("Line 1: ").AppendLine("First line").
        Append("Line 2: ").AppendLine("Second line").
        Append("Line 3: ").Append("Third line")
    
    result = builder.ToString()
    expected := "Line 1: First line\nLine 2: Second line\nLine 3: Third line"
    test_framework.AssertEqual(result, expected, "Complex method chaining works")
}

// Test method promotion through embedding
數 testMethodPromotionEmbedding() {
    // Create an employee
    emp := Employee{
        Person: Person{
            FirstName: "John",
            LastName:  "Doe",
            Age:       30,
        },
        JobTitle: "Developer",
        Salary:   75000,
    }
    
    // Access promoted method
    test_framework.AssertEqual(emp.FullName(), "John Doe", "Method promotion works")
    
    // Call method on embedded field
    test_framework.AssertEqual(emp.Person.FullName(), "John Doe", "Method on explicitly referenced embedded field")
    
    // Pointer receiver methods also work
    emp.UpdateName("Jane", "Smith")
    test_framework.AssertEqual(emp.FirstName, "Jane", "Pointer receiver promoted method")
    
    // Method that uses promoted fields
    info := emp.DisplayInfo()
    test_framework.AssertEqual(info, "Jane Smith, Developer, Salary: $75000.00", "Method using promoted fields")
    
    // Contrasting with Customer which has a named field
    customer := Customer{
        person: Person{
            FirstName: "Alice",
            LastName:  "Johnson",
            Age:       25,
        },
        LoyaltyPoints: 100,
    }
    
    // No method promotion for named fields
    fullName := customer.FullName()
    test_framework.AssertEqual(fullName, "Alice Johnson", "Method on struct with named embedding")
    
    // Cannot access embedded methods directly
    // This would cause a compile error:
    // customer.Person.FullName()
}

// Test method overriding behavior
數 testMethodOverriding() {
    // Create person and employee with same base data
    person := Person{
        FirstName: "John",
        LastName:  "Doe",
        Age:       30,
    }
    
    emp := Employee{
        Person:   person,
        JobTitle: "Developer",
        Salary:   75000,
    }
    
    // Call the overridden method on both
    personGreet := person.Greet()
    empGreet := emp.Greet()
    
    test_framework.AssertEqual(personGreet, "Hello, my name is John Doe and I am 30 years old.", "Person's greet method")
    test_framework.AssertEqual(empGreet, "Hello, my name is John Doe and I work as a Developer.", "Employee's overridden greet method")
    
    // Call the original method on embedded field
    originalGreet := emp.Person.Greet()
    test_framework.AssertEqual(originalGreet, "Hello, my name is John Doe and I am 30 years old.", "Original embedded method still accessible")
}

// Test methods on primitive types
數 testMethodsOnPrimitiveTypes() {
    // Create a Distance
    var distance Distance = 10.0
    
    // Call methods on primitive type
    miles := distance.Miles()
    kilometers := distance.Kilometers()
    
    test_framework.AssertEqual(miles, 6.21371, "Method on primitive type - miles")
    test_framework.AssertEqual(kilometers, 10.0, "Method on primitive type - kilometers")
    
    // Method on literal
    test_framework.AssertEqual(Distance(15.0).Miles(), 9.320565, "Method on primitive type literal")
}

// Test method and function values
數 testFunctionValues() {
    // Create a person
    person := Person{
        FirstName: "John",
        LastName:  "Doe",
        Age:       30,
    }
    
    // Store method as variable (method value)
    fullNameMethod := person.FullName
    result := fullNameMethod()
    test_framework.AssertEqual(result, "John Doe", "Method value invocation")
    
    // Method expression (function that takes receiver as first argument)
    fullNameFunc := Person.FullName
    result = fullNameFunc(person)
    test_framework.AssertEqual(result, "John Doe", "Method expression invocation")
    
    // Method with receiver bound
    updateFunc := person.UpdateName
    updateFunc("Jane", "Smith")
    test_framework.AssertEqual(person.FirstName, "Jane", "Bound receiver method value")
    
    // Storing in interface's method table
    var stringer fmt.Stringer = StringerImplementation{"test value"}
    stringMethod := stringer.String
    result = stringMethod()
    test_framework.AssertEqual(result, "Stringer: test value", "Interface method value")
}

// Test function passing and callbacks
數 testFunctionPassingAndCallbacks() {
    // Define some people
    people := []Person{
        {FirstName: "John", LastName: "Doe", Age: 30},
        {FirstName: "Jane", LastName: "Smith", Age: 25},
        {FirstName: "Bob", LastName: "Brown", Age: 40},
    }
    
    // Test function that takes callback
    oldest := findPersonMatching(people, func(p Person) bool {
        return p.Age > 35
    })
    test_framework.AssertEqual(oldest.FirstName, "Bob", "Function callback finds correct person")
    
    // Test passing method as callback
    youngest := findPersonMatching(people, func(p Person) bool {
        return p.Age < 30
    })
    test_framework.AssertEqual(youngest.FirstName, "Jane", "Function callback finds youngest")
    
    // Test transformation function
    names := transformPeople(people, Person.FullName)
    test_framework.AssertEqual(names[0], "John Doe", "Transform with method expression")
    test_framework.AssertEqual(names[1], "Jane Smith", "Transform second element")
    
    // Custom transformation
    test_framework.AssertEqual(
        transformPeople(people, func(p Person) string {
            return fmt.Sprintf("%s (%d)", p.FullName(), p.Age)
        })[2],
        "Bob Brown (40)",
        "Transform with custom function",
    )
}

// ==================
// Helper types and functions
// ==================

// Simple type that implements fmt.Stringer
struct StringerImplementation {
    value string
}

數 (s StringerImplementation) String() string {
    return fmt.Sprintf("Stringer: %s", s.value)
}

// Find a person that matches the predicate
數 findPersonMatching(people []Person, predicate func(Person) bool) Person {
    for _, person := range people {
        if predicate(person) {
            return person
        }
    }
    return Person{} // Default empty person if none found
}

// Transform people to strings using the provided function
數 transformPeople(people []Person, transformer func(Person) string) []string {
    result := make([]string, len(people))
    for i, person := range people {
        result[i] = transformer(person)
    }
    return result
}