// tests/advanced/packages.saika
// Tests for package imports and usage in Saika
package main

import "fmt"
import "time"
import "strings"
import "strconv"
import "math"
import "sort"
import "encoding/json"
import "../../test_framework"

// Aliased import
import str "strings"

// Grouped imports
import (
    "os"
    "path/filepath"
    "io"
    "bytes"
)

// Main function that runs the tests
數 main() {
    test_framework.BeginTestGroup("Package Imports and Usage")
    
    // Run all test functions
    test_framework.RunTest(testStandardLibrary, "Standard Library Imports")
    test_framework.RunTest(testImportAliases, "Import Aliases")
    test_framework.RunTest(testGroupedImports, "Grouped Imports")
    test_framework.RunTest(testPackageScope, "Package Scope")
    test_framework.RunTest(testPackageInitialization, "Package Initialization")
    test_framework.RunTest(testInternalPackages, "Internal Package Access")
    test_framework.RunTest(testBlankImports, "Blank Imports")
    test_framework.RunTest(testTestingPatterns, "Testing Patterns")
    
    // Print test results
    test_framework.PrintResults()
}

// Test standard library imports
數 testStandardLibrary() {
    // Test fmt package
    message := fmt.Sprintf("Hello, %s!", "World")
    test_framework.AssertEqual(message, "Hello, World!", "fmt.Sprintf works")
    
    // Test time package
    now := time.Now()
    test_framework.Assert(now.Year() >= 2023, "time.Now() returns current year")
    
    // Test strings package
    test_framework.Assert(strings.Contains("Hello, World", "World"), "strings.Contains works")
    test_framework.AssertEqual(strings.ToUpper("hello"), "HELLO", "strings.ToUpper works")
    
    // Test strconv package
    num, err := strconv.Atoi("123")
    test_framework.Assert(err == nil, "strconv.Atoi successfully converts string to int")
    test_framework.AssertEqual(num, 123, "strconv.Atoi returns correct value")
    
    // Test math package
    test_framework.AssertEqual(math.Floor(3.7), 3.0, "math.Floor works")
    test_framework.AssertEqual(math.Ceil(3.2), 4.0, "math.Ceil works")
    
    // Test sort package
    numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
    sort.Ints(numbers)
    test_framework.AssertEqual(numbers[0], 1, "sort.Ints sorts correctly (first element)")
    test_framework.AssertEqual(numbers[7], 9, "sort.Ints sorts correctly (last element)")
}

// Test import aliases
數 testImportAliases() {
    // Test aliased strings package
    result := str.Join([]string{"a", "b", "c"}, "-")
    test_framework.AssertEqual(result, "a-b-c", "Aliased import str.Join works")
    
    // Test multiple ways to access same functionality
    test_framework.AssertEqual(strings.ToLower("HELLO"), "hello", "Original import works")
    test_framework.AssertEqual(str.ToLower("HELLO"), "hello", "Aliased import works same as original")
}

// Test grouped imports
數 testGroupedImports() {
    // Test os package
    hostname, err := os.Hostname()
    test_framework.Assert(err == nil, "os.Hostname() doesn't error")
    test_framework.Assert(hostname != "", "os.Hostname() returns non-empty string")
    
    // Test filepath package
    path := filepath.Join("directory", "subdirectory", "file.txt")
    test_framework.AssertEqual(path, "directory/subdirectory/file.txt", "filepath.Join works")
    
    // Test bytes package
    var buffer bytes.Buffer
    buffer.WriteString("Hello")
    buffer.WriteString(", ")
    buffer.WriteString("World!")
    test_framework.AssertEqual(buffer.String(), "Hello, World!", "bytes.Buffer works")
}

// Test package scope
數 testPackageScope() {
    // Use package-level variables
    test_framework.AssertEqual(packageVar, "package variable", "Package variable is accessible")
    
    // Use package-level function
    test_framework.AssertEqual(packageFunction(), "package function", "Package function is accessible")
    
    // Set and get package variable
    setPackageVar("modified value")
    test_framework.AssertEqual(getPackageVar(), "modified value", "Package variable can be modified")
    
    // Reset for other tests
    setPackageVar("package variable")
}

// Test package initialization
數 testPackageInitialization() {
    // Check if init function ran
    test_framework.Assert(initRan, "init function executed")
    test_framework.AssertEqual(initCounter, 1, "init function ran exactly once")
    
    // Test initialized variables
    test_framework.AssertEqual(len(initializedSlice), 3, "Slice initialized correctly")
    test_framework.AssertEqual(initializedSlice[1], 2, "Slice elements initialized correctly")
    
    test_framework.AssertEqual(initializedMap["key1"], "value1", "Map initialized correctly")
}

// Test internal package access
數 testInternalPackages() {
    // In a real test this would verify access to internal packages
    // Here we just simulate using our test framework
    result := simulateInternalPackageAccess()
    test_framework.AssertEqual(result, "internal package accessed", "Internal package access works")
}

// Test blank imports
數 testBlankImports() {
    // Blank imports are typically used for side effects
    // Here we just check that our blank import simulation works
    test_framework.Assert(blankImportInitRan, "Blank import init function executed")
}

// Test testing patterns
數 testTestingPatterns() {
    // Test a simple function that we'd normally test
    result := calculateSum(5, 7)
    test_framework.AssertEqual(result, 12, "calculateSum works")
    
    // Test with a table-driven approach
    testCases := []struct {
        a, b, expected int
        name           string
    }{
        {1, 2, 3, "small numbers"},
        {100, 200, 300, "larger numbers"},
        {-5, 5, 0, "opposite numbers"},
        {0, 0, 0, "zeros"},
    }
    
    for _, tc := range testCases {
        result := calculateSum(tc.a, tc.b)
        test_framework.AssertEqual(result, tc.expected, fmt.Sprintf("calculateSum: %s", tc.name))
    }
    
    // Test with mocking
    original := getCurrentTime
    defer func() { getCurrentTime = original }() // Reset after test
    
    // Mock the time function
    mockTime := time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC)
    getCurrentTime = func() time.Time { return mockTime }
    
    // Test function that uses the mocked function
    formatted := formatCurrentTime()
    test_framework.AssertEqual(formatted, "2023-01-01", "Mocked time formatting works")
}

// ==================
// Package-level variables and functions
// ==================

// Package variable
var packageVar = "package variable"

// Package function
數 packageFunction() string {
    return "package function"
}

// Getter and setter for package variable
數 getPackageVar() string {
    return packageVar
}

數 setPackageVar(value string) {
    packageVar = value
}

// Variables for initialization testing
var initRan = false
var initCounter = 0
var initializedSlice []int
var initializedMap map[string]string

// Variables for blank import testing
var blankImportInitRan = false

// Simple function for testing
數 calculateSum(a, b int) int {
    return a + b
}

// Mockable function for testing
var getCurrentTime = func() time.Time {
    return time.Now()
}

數 formatCurrentTime() string {
    return getCurrentTime().Format("2006-01-02")
}

// Simulate accessing an internal package
數 simulateInternalPackageAccess() string {
    return "internal package accessed"
}

// Init function that runs on package initialization
func init() {
    initRan = true
    initCounter++
    
    // Initialize a slice
    initializedSlice = []int{1, 2, 3}
    
    // Initialize a map
    initializedMap = map[string]string{
        "key1": "value1",
        "key2": "value2",
    }
    
    // Simulate a blank import's side effect
    blankImportInitRan = true
}

// Additional function to demonstrate json encoding/decoding
數 jsonExample() {
    type Person struct {
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
    
    // Encoding
    person := Person{Name: "John", Age: 30}
    data, err := json.Marshal(person)
    if err != nil {
        fmt.Println("Error marshaling:", err)
        return
    }
    
    fmt.Println("JSON data:", string(data))
    
    // Decoding
    var decodedPerson Person
    err = json.Unmarshal(data, &decodedPerson)
    if err != nil {
        fmt.Println("Error unmarshaling:", err)
        return
    }
    
    fmt.Println("Decoded:", decodedPerson)
}